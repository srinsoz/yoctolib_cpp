<HTML>
<HEAD>
<title>C++ API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-cpp-EN.html 10750 2013-03-28 08:47:03Z mvuilleu $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce 
 *    and Licensee are governed by Yoctopuce General Terms and 
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived 
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute; 
  left:0px; 
  top:0px; 
  width:800px; 
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute; 
  left:0px; 
  top:80px; 
  width:250px; 
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;
 
}

div#FunctionsLayer
{ position:absolute; 
  left:250px; 
  top:80px; 
  width:600px; 
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute; 
  left:0px; 
  top:570px; 
  width: 800px; 
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute; 
  width:10px; 
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize; 
}

div.container
{ width:100%;
  height:100%;
}
 
span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
} 

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }
 
span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }
 
div.methodsList
 { margin-top:0px;
   padding-top:0px;   
   padding-left:10px;
   margin-bottom:10px;
 } 

div.methodsList A
 { color: navy;
   text-decoration:none;
 }
 
div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }
 
span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }
  
span#pn , td.pn
 { font-weight:bold; 
   color:#004000;
   
 } 
 
td.pn
 {vertical-align:top}
 
span.paramAndRet
 {font-weight:bold;

 } 
 
table
 {font-size:14px;}
 
span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;   
   background-color: #f8f8f8; 
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }
 
p.protolabel
 { border-top:1px  solid #f0f0f0;
 }
 
P.protoretval
 { margin-left:20px;}

.paramtable 
 { margin-left:20px; margin-top:0px;}
  
P.protoretval
 { margin-left:20px;}
 
input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }
 
td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040; 
 }
 
td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }
 
p.methodlist
 { border-top:1px solid #e0e0e0;
 } 
 
a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 } 
 
span.synlist
 { margin-left:10px;
 } 
 
p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }  
</style>

<SCRIPT type="text/JavaScript" language="javascript1.5">
<!--
var WinW; 
var WinH; 

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array(); 
var SVN_Id = '$Id: yoctolib-cpp-EN.html 10750 2013-03-28 08:47:03Z mvuilleu $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'General functions',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>These general functions should be used to initialize and configure the Yoctopuce library. In most cases, a simple call to function <tt>yRegisterHub()</tt> should be enough. The module-specific functions <tt>yFind...()</tt> or <tt>yFirst...()</tt> should then be used to retrieve an object that provides interaction with the module.</p>'}};
doc['YAPI']['CheckLogicalName']={syn:'Checks if a given string is valid as logical name for a module or a function.',lib:'YAPI::CheckLogicalName()',pro:'bool CheckLogicalName(const string&amp; <span id=pn>name</span>)',cmt:'<p>Checks if a given string is valid as logical name for a module or a function. A valid logical name has a maximum of 19 characters, all among <tt>A..Z</tt>, <tt>a..z</tt>, <tt>0..9</tt>, <tt>_</tt>, and <tt>-</tt>. If you try to configure a logical name with an incorrect string, the invalid characters are ignored.</p>',par:{name:'a string containing the name to check.'},ret:'<tt>true</tt> if the name is valid, <tt>false</tt> otherwise.'};
doc['YAPI']['DisableExceptions']={syn:'Disables the use of exceptions to report runtime errors.',lib:'YAPI::DisableExceptions()',pro:'void DisableExceptions()',cmt:'<p>Disables the use of exceptions to report runtime errors. When exceptions are disabled, every function returns a specific error value which depends on its type and which is documented in this reference manual.</p>'};
doc['YAPI']['EnableExceptions']={syn:'Re-enables the use of exceptions for runtime error handling.',lib:'YAPI::EnableExceptions()',pro:'void EnableExceptions()',cmt:'<p>Re-enables the use of exceptions for runtime error handling. Be aware than when exceptions are enabled, every function that fails triggers an exception. If the exception is not caught by the user code, it either fires the debugger or aborts (i.e. crash) the program. On failure, throws an exception or returns a negative error code.</p>'};
doc['YAPI']['FreeAPI']={syn:'Frees dynamically allocated memory blocks used by the Yoctopuce library.',lib:'YAPI::FreeAPI()',pro:'void FreeAPI()',cmt:'<p>Frees dynamically allocated memory blocks used by the Yoctopuce library. It is generally not required to call this function, unless you want to free all dynamically allocated memory blocks in order to track a memory leak for instance. You should not call any other library function after calling <tt>yFreeAPI()</tt>, or your program will crash.</p>'};
doc['YAPI']['GetAPIVersion']={syn:'Returns the version identifier for the Yoctopuce library in use.',lib:'YAPI::GetAPIVersion()',pro:'string GetAPIVersion()',cmt:'<p>Returns the version identifier for the Yoctopuce library in use. The version is a string in the form <tt>\x22Major.Minor.Build\x22</tt>, for instance <tt>\x221.01.5535\x22</tt>. For languages using an external DLL (for instance C#, VisualBasic or Delphi), the character string includes as well the DLL version, for instance <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> If you want to verify in your code that the library version is compatible with the version that you have used during development, verify that the major number is strictly equal and that the minor number is greater or equal. The build number is not relevant with respect to the library compatibility.</p>',ret:'a character string describing the library version.'};
doc['YAPI']['GetTickCount']={syn:'Returns the current value of a monotone millisecond-based time counter.',lib:'YAPI::GetTickCount()',pro:'u64 GetTickCount()',cmt:'<p>Returns the current value of a monotone millisecond-based time counter. This counter can be used to compute delays in relation with Yoctopuce devices, which also uses the milisecond as timebase.</p>',ret:'a long integer corresponding to the millisecond counter.'};
doc['YAPI']['HandleEvents']={syn:'Maintains the device-to-library communication channel.',lib:'YAPI::HandleEvents()',pro:'YRETCODE HandleEvents(string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Maintains the device-to-library communication channel. If your program includes significant loops, you may want to include a call to this function to make sure that the library takes care of the information pushed by the modules on the communication channels. This is not strictly necessary, but it may improve the reactivity of the library for the following commands.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['InitAPI']={syn:'Initializes the Yoctopuce programming library explicitly.',lib:'YAPI::InitAPI()',pro:'YRETCODE InitAPI(int <span id=pn>mode</span>, string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Initializes the Yoctopuce programming library explicitly. It is not strictly needed to call <tt>yInitAPI()</tt>, as the library is automatically initialized when calling <tt>yRegisterHub()</tt> for the first time.</p><p> When <tt>Y_DETECT_NONE</tt> is used as detection <tt>mode</tt>, you must explicitly use <tt>yRegisterHub()</tt> to point the API to the VirtualHub on which your devices are connected before trying to access them.</p>',par:{mode:'an integer corresponding to the type of automatic device detection to use. Possible values are <tt>Y_DETECT_NONE</tt>, <tt>Y_DETECT_USB</tt>, <tt>Y_DETECT_NET</tt>, and <tt>Y_DETECT_ALL</tt>.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterDeviceArrivalCallback']={syn:'Register a callback function, to be called each time a device is pluged.',lib:'YAPI::RegisterDeviceArrivalCallback()',pro:'void RegisterDeviceArrivalCallback(yDeviceUpdateCallback <span id=pn>arrivalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is pluged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{arrivalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterDeviceRemovalCallback']={syn:'Register a callback function, to be called each time a device is unpluged.',lib:'YAPI::RegisterDeviceRemovalCallback()',pro:'void RegisterDeviceRemovalCallback(yDeviceUpdateCallback <span id=pn>removalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is unpluged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{removalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterHub']={syn:'Setup the Yoctopuce library to use modules connected on a given machine.',lib:'YAPI::RegisterHub()',pro:'YRETCODE RegisterHub(const string&amp; <span id=pn>url</span>, string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Setup the Yoctopuce library to use modules connected on a given machine. When using Yoctopuce modules through the VirtualHub gateway, you should provide as parameter the address of the machine on which the VirtualHub software is running (typically <tt>\x22http://127.0.0.1:4444\x22</tt>, which represents the local machine). When you use a language which has direct access to the USB hardware, you can use the pseudo-URL <tt>\x22usb\x22</tt> instead.</p><p> Be aware that only one application can use direct USB access at a given time on a machine. Multiple access would cause conflicts while trying to access the USB modules. In particular, this means that you must stop the VirtualHub software before starting an application that uses direct USB access. The workaround for this limitation is to setup the library to use the VirtualHub rather than direct USB access. If acces control has been activated on the VirtualHub you want to reach, the URL parameter should look like: <tt>http://username:password</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterLogFunction']={syn:'Registers a log callback function.',lib:'YAPI::RegisterLogFunction()',pro:'void RegisterLogFunction(yLogFunction <span id=pn>logfun</span>)',cmt:'<p>Registers a log callback function. This callback will be called each time the API have something to say. Quite usefull to debug the API.</p>',par:{logfun:'a procedure taking a string parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['Sleep']={syn:'Pauses the execution flow for a specified duration.',lib:'YAPI::Sleep()',pro:'YRETCODE Sleep(unsigned <span id=pn>ms_duration</span>, string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Pauses the execution flow for a specified duration. This function implements a passive waiting loop, meaning that it does not consume CPU cycles significatively. The processor is left available for other threads and processes. During the pause, the library nevertheless reads from time to time information from the Yoctopuce modules by calling <tt>yHandleEvents()</tt>, in order to stay up-to-date.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{ms_duration:'an integer corresponding to the duration of the pause, in milliseconds.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['UnregisterHub']={syn:'Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.',lib:'YAPI::UnregisterHub()',pro:'void UnregisterHub(const string&amp; <span id=pn>url</span>)',cmt:'<p>Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui> or the root URL of the hub to monitor'}};
doc['YAPI']['UpdateDeviceList']={syn:'Triggers a (re)detection of connected Yoctopuce modules.',lib:'YAPI::UpdateDeviceList()',pro:'YRETCODE UpdateDeviceList(string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Triggers a (re)detection of connected Yoctopuce modules. The library searches the machines or USB ports previously registered using <tt>yRegisterHub()</tt>, and invokes any user-defined callback function in case a change in the list of connected devices is detected.</p><p> This function can be called as frequently as desired to refresh the device list and to make the application aware of hot-plug events.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: YAPI)
//--- (generated code: DataStream)
doc['DataStream']={'':{syn:'Recorded data sequence',inc:'#include &quot;yocto_datalogger.h&quot;',cmt:'<p>DataStream objects represent a recorded measure sequence. They are returned by the data logger present on Yoctopuce sensors.</p>'}};
doc['DataStream']['get_columnCount']={syn:'Returns the number of data columns present in this stream.',lib:'datastream&rarr;get_columnCount()',pro:'unsigned get_columnCount()',cmt:'<p>Returns the number of data columns present in this stream. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'an unsigned number corresponding to the number of rows. On failure, throws an exception or returns zero.'};
doc['DataStream']['get_columnNames']={syn:'Returns the title (or meaning) of each data column present in this stream.',lib:'datastream&rarr;get_columnNames()',pro:'const vector&lt;string&gt;&amp; get_columnNames()',cmt:'<p>Returns the title (or meaning) of each data column present in this stream. In most case, the title of the data column is the hardware identifier of the sensor that produced the data. For archived streams created by summarizing a high-resolution data stream, there can be a suffix appended to the sensor identifier, such as _min for the minimum value, _avg for the average value and _max for the maximal value.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'a list containing as many strings as there are columns in the data stream. On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_data']={syn:'Returns a single measure from the data stream, specified by its row and column index.',lib:'datastream&rarr;get_data()',pro:'double get_data(unsigned <span id=pn>row</span>, unsigned <span id=pn>col</span>)',cmt:'<p>Returns a single measure from the data stream, specified by its row and column index. The meaning of the values present in each column can be obtained using the method get_columnNames().</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',par:{row:'row index',col:'column index'},ret:'a floating-point number On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_dataRows']={syn:'Returns the whole data set contained in the stream, as a bidimensional table of numbers.',lib:'datastream&rarr;get_dataRows()',pro:'const vector&lt; vector&lt;double&gt; &gt;&amp; get_dataRows()',cmt:'<p>Returns the whole data set contained in the stream, as a bidimensional table of numbers. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'a list containing as many elements as there are rows in the data stream. Each row itself is a list of floating-point numbers. On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_dataSamplesInterval']={syn:'Returns the number of seconds elapsed between two consecutive rows of this data stream.',lib:'datastream&rarr;get_dataSamplesInterval()',pro:'unsigned get_dataSamplesInterval()',cmt:'<p>Returns the number of seconds elapsed between two consecutive rows of this data stream. By default, the data logger records one row per second, but there might be alternative streams at lower resolution created by summarizing the original stream for archiving purposes.</p><p> This method does not cause any access to the device, as the value is preloaded in the object at instantiation time.</p>',ret:'an unsigned number corresponding to a number of seconds.'};
doc['DataStream']['get_rowCount']={syn:'Returns the number of data rows present in this stream.',lib:'datastream&rarr;get_rowCount()',pro:'unsigned get_rowCount()',cmt:'<p>Returns the number of data rows present in this stream.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'an unsigned number corresponding to the number of rows. On failure, throws an exception or returns zero.'};
doc['DataStream']['get_runIndex']={syn:'Returns the run index of the data stream.',lib:'datastream&rarr;get_runIndex()',pro:'unsigned get_runIndex()',cmt:'<p>Returns the run index of the data stream. A run can be made of multiple datastreams, for different time intervals. This method does not cause any access to the device, as the value is preloaded in the object at instantiation time. </p>',ret:'an unsigned number corresponding to the run index.'};
doc['DataStream']['get_startTime']={syn:'Returns the start time of the data stream, relative to the beginning of the run.',lib:'datastream&rarr;get_startTime()',pro:'unsigned get_startTime()',cmt:'<p>Returns the start time of the data stream, relative to the beginning of the run. If you need an absolute time, use <tt>get_startTimeUTC()</tt>.</p><p> This method does not cause any access to the device, as the value is preloaded in the object at instantiation time.</p>',ret:'an unsigned number corresponding to the number of seconds between the start of the run and the beginning of this data stream.'};
doc['DataStream']['get_startTimeUTC']={syn:'Returns the start time of the data stream, relative to the Jan 1, 1970.',lib:'datastream&rarr;get_startTimeUTC()',pro:'const time_t &amp; get_startTimeUTC()',cmt:'<p>Returns the start time of the data stream, relative to the Jan 1, 1970. If the UTC time was not set in the datalogger at the time of the recording of this data stream, this method returns 0.</p><p> This method does not cause any access to the device, as the value is preloaded in the object at instantiation time.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data stream (i.e. Unix time representation of the absolute time).'};
//--- (end of generated code: DataStream)
//--- (generated code: Module)
var Language='C++';
var IncludeLabel='In order to use the functions described here, you should include:';
var ParamLabel='Parameters :';
var ReturnLabel='Returns :';
var AbbrevHint='The API features two syntaxes : one is purely object oriented, the other is more compact.';
var NotFound='No match found';
var AbbrevLabel='Use abbreviated names';
var UseShortcuts=true;
var sub={YAPI_SUCCESS:'YAPI::SUCCESS',YAPI_NOT_INITIALIZED:'YAPI::NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'YAPI::INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'YAPI::NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'YAPI::DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'YAPI::VERSION_MISMATCH',YAPI_DEVICE_BUSY:'YAPI::DEVICE_BUSY',YAPI_TIMEOUT:'YAPI::TIMEOUT',YAPI_IO_ERROR:'YAPI::IO_ERROR',YAPI_NO_MORE_DATA:'YAPI::NO_MORE_DATA',YAPI_EXHAUSTED:'YAPI::EXHAUSTED',YAPI_DOUBLE_ACCES:'YAPI::DOUBLE_ACCES',YAPI_UNAUTHORIZED:'YAPI::UNAUTHORIZED',null:'NULL'};
doc['Module']={'':{syn:'Module control interface',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>This interface is identical for all Yoctopuce USB modules. It can be used to control the module global parameters, and to enumerate the functions provided by each module.</p>'}};
doc['Module']['FindModule']={syn:'Allows you to find a module from its serial number or from its logical name.',lib:'YModule::FindModule()',pro:'YModule* FindModule(const string&amp; <span id=pn>func</span>)',cmt:'<p>Allows you to find a module from its serial number or from its logical name.</p><p> This function does not require that the module is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YModule.isOnline()</tt> to test if the module is indeed online at a given time. In case of ambiguity when looking for a module by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string containing either the serial number or the logical name of the desired module'},ret:'a <tt>YModule</tt> object allowing you to drive the module or get additional information on the module.'};
doc['Module']['FirstModule']={syn:'Starts the enumeration of modules currently accessible.',lib:'YModule::FirstModule()',pro:'YModule* FirstModule()',cmt:'<p>Starts the enumeration of modules currently accessible. Use the method <tt>YModule.nextModule()</tt> to iterate on the next modules.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the first module currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Module']['describe']={syn:'Returns a descriptive text that identifies the module.',lib:'module&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a descriptive text that identifies the module. The text may include either the logical name or the serial number of the module.</p>',ret:'a string that describes the module'};
doc['Module']['functionCount']={syn:'Returns the number of functions (beside the \x22module\x22 interface) available on the module.',lib:'module&rarr;functionCount()',pro:'int functionCount()',cmt:'<p>Returns the number of functions (beside the \x22module\x22 interface) available on the module.</p>',ret:'the number of functions on the module',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['functionId']={syn:'Retrieves the hardware identifier of the <i>n</i>th function on the module.',lib:'module&rarr;functionId()',pro:'string functionId(int <span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the hardware identifier of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the unambiguous hardware identifier of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionName']={syn:'Retrieves the logical name of the <i>n</i>th function on the module.',lib:'module&rarr;functionName()',pro:'string functionName(int <span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the logical name of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the logical name of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionValue']={syn:'Retrieves the advertised value of the <i>n</i>th function on the module.',lib:'module&rarr;functionValue()',pro:'string functionValue(int <span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the advertised value of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a short string (up to 6 characters) corresponding to the advertised value of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['get_beacon']={syn:'Returns the state of the localization beacon.',lib:'module&rarr;get_beacon()',pro:'Y_BEACON_enum get_beacon()',cmt:'<p>Returns the state of the localization beacon.</p>',ret:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>, according to the state of the localization beacon',ext:'On failure, throws an exception or returns <tt>Y_BEACON_INVALID</tt>.'};
doc['Module']['get_errorMessage']={syn:'Returns the error message of the last error with this module object.',lib:'module&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the last error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the last error message that occured while using this module object'};
doc['Module']['get_errorType']={syn:'Returns the numerical error code of the last error with this module object.',lib:'module&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the last error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the last error that occured while using this module object'};
doc['Module']['get_firmwareRelease']={syn:'Returns the version of the firmware embedded in the module.',lib:'module&rarr;get_firmwareRelease()',pro:'string get_firmwareRelease()',cmt:'<p>Returns the version of the firmware embedded in the module.</p>',ret:'a string corresponding to the version of the firmware embedded in the module',ext:'On failure, throws an exception or returns <tt>Y_FIRMWARERELEASE_INVALID</tt>.'};
doc['Module']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'module&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Module']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'module&rarr;get_moduleDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Module']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'module&rarr;get_moduleId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Module']['get_hardwareId']={syn:'Returns the unique hardware identifier of the module.',lib:'module&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the module. The unique hardware identifier is made of the device serial number followed by string \x22.module\x22.</p>',ret:'a string that uniquely identifies the module'};
doc['Module']['get_icon2d']={syn:'Returns the icon of the module.',lib:'module&rarr;get_icon2d()',pro:'string get_icon2d()',cmt:'<p>Returns the icon of the module. The icon is a PNG image and does not exceeds 1536 bytes.</p>',ret:'a binary buffer with module icon, in png format.'};
doc['Module']['get_logicalName']={syn:'Returns the logical name of the module.',lib:'module&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the module.</p>',ret:'a string corresponding to the logical name of the module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Module']['get_luminosity']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'module&rarr;get_luminosity()',pro:'int get_luminosity()',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Module']['get_persistentSettings']={syn:'Returns the current state of persistent module settings.',lib:'module&rarr;get_persistentSettings()',pro:'Y_PERSISTENTSETTINGS_enum get_persistentSettings()',cmt:'<p>Returns the current state of persistent module settings.</p>',ret:'a value among <tt>Y_PERSISTENTSETTINGS_LOADED</tt>, <tt>Y_PERSISTENTSETTINGS_SAVED</tt> and <tt>Y_PERSISTENTSETTINGS_MODIFIED</tt> corresponding to the current state of persistent module settings',ext:'On failure, throws an exception or returns <tt>Y_PERSISTENTSETTINGS_INVALID</tt>.'};
doc['Module']['get_productId']={syn:'Returns the USB device identifier of the module.',lib:'module&rarr;get_productId()',pro:'int get_productId()',cmt:'<p>Returns the USB device identifier of the module.</p>',ret:'an integer corresponding to the USB device identifier of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTID_INVALID</tt>.'};
doc['Module']['get_productName']={syn:'Returns the commercial name of the module, as set by the factory.',lib:'module&rarr;get_productName()',pro:'string get_productName()',cmt:'<p>Returns the commercial name of the module, as set by the factory.</p>',ret:'a string corresponding to the commercial name of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTNAME_INVALID</tt>.'};
doc['Module']['get_productRelease']={syn:'Returns the hardware release version of the module.',lib:'module&rarr;get_productRelease()',pro:'int get_productRelease()',cmt:'<p>Returns the hardware release version of the module.</p>',ret:'an integer corresponding to the hardware release version of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTRELEASE_INVALID</tt>.'};
doc['Module']['get_rebootCountdown']={syn:'Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.',lib:'module&rarr;get_rebootCountdown()',pro:'int get_rebootCountdown()',cmt:'<p>Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_REBOOTCOUNTDOWN_INVALID</tt>.'};
doc['Module']['get_serialNumber']={syn:'Returns the serial number of the module, as set by the factory.',lib:'module&rarr;get_serialNumber()',pro:'string get_serialNumber()',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_SERIALNUMBER_INVALID</tt>.'};
doc['Module']['get_upTime']={syn:'Returns the number of milliseconds spent since the module was powered on.',lib:'module&rarr;get_upTime()',pro:'unsigned get_upTime()',cmt:'<p>Returns the number of milliseconds spent since the module was powered on.</p>',ret:'an integer corresponding to the number of milliseconds spent since the module was powered on',ext:'On failure, throws an exception or returns <tt>Y_UPTIME_INVALID</tt>.'};
doc['Module']['get_usbBandwidth']={syn:'Returns the number of USB interfaces used by the module.',lib:'module&rarr;get_usbBandwidth()',pro:'Y_USBBANDWIDTH_enum get_usbBandwidth()',cmt:'<p>Returns the number of USB interfaces used by the module.</p>',ret:'either <tt>Y_USBBANDWIDTH_SIMPLE</tt> or <tt>Y_USBBANDWIDTH_DOUBLE</tt>, according to the number of USB interfaces used by the module',ext:'On failure, throws an exception or returns <tt>Y_USBBANDWIDTH_INVALID</tt>.'};
doc['Module']['get_usbCurrent']={syn:'Returns the current consumed by the module on the USB bus, in milli-amps.',lib:'module&rarr;get_usbCurrent()',pro:'unsigned get_usbCurrent()',cmt:'<p>Returns the current consumed by the module on the USB bus, in milli-amps.</p>',ret:'an integer corresponding to the current consumed by the module on the USB bus, in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_USBCURRENT_INVALID</tt>.'};
doc['Module']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'module&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Module']['isOnline']={syn:'Checks if the module is currently reachable, without raising any error.',lib:'module&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the module is currently reachable, without raising any error. If there are valid cached values for the module, that have not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the requested module.</p>',ret:'<tt>true</tt> if the module can be reached, and <tt>false</tt> otherwise'};
doc['Module']['load']={syn:'Preloads the module cache with a specified validity duration.',lib:'module&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the module cache with a specified validity duration. By default, whenever accessing a device, all module attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded module parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Module']['nextModule']={syn:'Continues the module enumeration started using <tt>yFirstModule()</tt>.',lib:'module&rarr;nextModule()',pro:'YModule * nextModule()',cmt:'<p>Continues the module enumeration started using <tt>yFirstModule()</tt>.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the next module found, or a <tt>null</tt> pointer if there are no more modules to enumerate.'};
doc['Module']['reboot']={syn:'Schedules a simple module reboot after the given number of seconds.',lib:'module&rarr;reboot()',pro:'int reboot(int <span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a simple module reboot after the given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['revertFromFlash']={syn:'Reloads the settings stored in the nonvolatile memory, as when the module is powered on.',lib:'module&rarr;revertFromFlash()',pro:'int revertFromFlash()',cmt:'<p>Reloads the settings stored in the nonvolatile memory, as when the module is powered on.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['saveToFlash']={syn:'Saves current settings in the nonvolatile memory of the module.',lib:'module&rarr;saveToFlash()',pro:'int saveToFlash()',cmt:'<p>Saves current settings in the nonvolatile memory of the module. Warning: the number of allowed save operations during a module life is limited (about 100000 cycles). Do not call this function within a loop.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_beacon']={syn:'Turns on or off the module localization beacon.',lib:'module&rarr;set_beacon()',pro:'int set_beacon(Y_BEACON_enum <span id=pn>newval</span>)',cmt:'<p>Turns on or off the module localization beacon.</p>',par:{newval:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_logicalName']={syn:'Changes the logical name of the module.',lib:'module&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_luminosity']={syn:'Changes the luminosity of the module informative leds.',lib:'module&rarr;set_luminosity()',pro:'int set_luminosity(int <span id=pn>newval</span>)',cmt:'<p>Changes the luminosity of the module informative leds. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the luminosity of the module informative leds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_usbBandwidth']={syn:'Changes the number of USB interfaces used by the module.',lib:'module&rarr;set_usbBandwidth()',pro:'int set_usbBandwidth(Y_USBBANDWIDTH_enum <span id=pn>newval</span>)',cmt:'<p>Changes the number of USB interfaces used by the module. You must reboot the module after changing this setting.</p>',par:{newval:'either <tt>Y_USBBANDWIDTH_SIMPLE</tt> or <tt>Y_USBBANDWIDTH_DOUBLE</tt>, according to the number of USB interfaces used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'module&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Module']['triggerFirmwareUpdate']={syn:'Schedules a module reboot into special firmware update mode.',lib:'module&rarr;triggerFirmwareUpdate()',pro:'int triggerFirmwareUpdate(int <span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a module reboot into special firmware update mode.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Module)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Temperature function interface',inc:'#include &quot;yocto_temperature.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Temperature']['FindTemperature']={syn:'Retrieves a temperature sensor for a given identifier.',lib:'YTemperature::FindTemperature()',pro:'YTemperature* FindTemperature(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a temperature sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the temperature sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTemperature.isOnline()</tt> to test if the temperature sensor is indeed online at a given time. In case of ambiguity when looking for a temperature sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the temperature sensor'},ret:'a <tt>YTemperature</tt> object allowing you to drive the temperature sensor.'};
doc['Temperature']['FirstTemperature']={syn:'Starts the enumeration of temperature sensors currently accessible.',lib:'YTemperature::FirstTemperature()',pro:'YTemperature* FirstTemperature()',cmt:'<p>Starts the enumeration of temperature sensors currently accessible. Use the method <tt>YTemperature.nextTemperature()</tt> to iterate on next temperature sensors.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to the first temperature sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Temperature']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'temperature&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a lineat interpolatation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'temperature&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Temperature']['get_advertisedValue']={syn:'Returns the current value of the temperature sensor (no more than 6 characters).',lib:'temperature&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the temperature sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the temperature sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'temperature&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentValue']={syn:'Returns the current measured value.',lib:'temperature&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Temperature']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'temperature&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Temperature']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'temperature&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Temperature']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'temperature&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Temperature']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'temperature&rarr;get_temperatureDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Temperature']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'temperature&rarr;get_temperatureId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Temperature']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'temperature&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Temperature']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'temperature&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_logicalName']={syn:'Returns the logical name of the temperature sensor.',lib:'temperature&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the temperature sensor.</p>',ret:'a string corresponding to the logical name of the temperature sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Temperature']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'temperature&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'temperature&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Temperature']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'temperature&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Temperature']['get_sensorType']={syn:'Returns the tempeture sensor type.',lib:'temperature&rarr;get_sensorType()',pro:'Y_SENSORTYPE_enum get_sensorType()',cmt:'<p>Returns the tempeture sensor type.</p>',ret:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt> and <tt>Y_SENSORTYPE_TYPE_T</tt> corresponding to the tempeture sensor type',ext:'On failure, throws an exception or returns <tt>Y_SENSORTYPE_INVALID</tt>.'};
doc['Temperature']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'temperature&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Temperature']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'temperature&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Temperature']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'temperature&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Temperature']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'temperature&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['nextTemperature']={syn:'Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.',lib:'temperature&rarr;nextTemperature()',pro:'YTemperature * nextTemperature()',cmt:'<p>Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to a temperature sensor currently online, or a <tt>null</tt> pointer if there are no more temperature sensors to enumerate.'};
doc['Temperature']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'temperature&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Temperature']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'temperature&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_logicalName']={syn:'Changes the logical name of the temperature sensor.',lib:'temperature&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the temperature sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the temperature sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'temperature&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_sensorType']={syn:'Modify the temperature sensor type.',lib:'temperature&rarr;set_sensorType()',pro:'int set_sensorType(Y_SENSORTYPE_enum <span id=pn>newval</span>)',cmt:'<p>Modify the temperature sensor type. This function is used to to define the type of thermo couple (K,E...) used with the device. This will have no effect if module is using a digital sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt> and <tt>Y_SENSORTYPE_TYPE_T</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'temperature&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'DataLogger function interface',inc:'#include &quot;yocto_datalogger.h&quot;',cmt:'<p>Yoctopuce sensors include a non-volatile memory capable of storing ongoing measured data automatically, without requiring a permanent connection to a computer. The Yoctopuce application programming interface includes functions to control how this internal data logger works. Beacause the sensors do not include a battery, they do not have an absolute time reference. Therefore, measures are simply indexed by the absolute run number and time relative to the start of the run. Every new power up starts a new run. It is however possible to setup an absolute UTC time by software at a given time, so that the data logger keeps track of it until it is next powered off.</p>'}};
doc['DataLogger']['FindDataLogger']={syn:'Retrieves a data logger for a given identifier.',lib:'YDataLogger::FindDataLogger()',pro:'YDataLogger* FindDataLogger(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a data logger for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the data logger is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDataLogger.isOnline()</tt> to test if the data logger is indeed online at a given time. In case of ambiguity when looking for a data logger by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the data logger'},ret:'a <tt>YDataLogger</tt> object allowing you to drive the data logger.'};
doc['DataLogger']['FirstDataLogger']={syn:'Starts the enumeration of data loggers currently accessible.',lib:'YDataLogger::FirstDataLogger()',pro:'YDataLogger* FirstDataLogger()',cmt:'<p>Starts the enumeration of data loggers currently accessible. Use the method <tt>YDataLogger.nextDataLogger()</tt> to iterate on next data loggers.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to the first data logger currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DataLogger']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'datalogger&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DataLogger']['forgetAllDataStreams']={syn:'Clears the data logger memory and discards all recorded data streams.',lib:'datalogger&rarr;forgetAllDataStreams()',pro:'int forgetAllDataStreams()',cmt:'<p>Clears the data logger memory and discards all recorded data streams. This method also resets the current run index to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['get_advertisedValue']={syn:'Returns the current value of the data logger (no more than 6 characters).',lib:'datalogger&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the data logger (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the data logger (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DataLogger']['get_autoStart']={syn:'Returns the default activation state of the data logger on power up.',lib:'datalogger&rarr;get_autoStart()',pro:'Y_AUTOSTART_enum get_autoStart()',cmt:'<p>Returns the default activation state of the data logger on power up.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['DataLogger']['get_currentRunIndex']={syn:'Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.',lib:'datalogger&rarr;get_currentRunIndex()',pro:'unsigned get_currentRunIndex()',cmt:'<p>Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.</p>',ret:'an integer corresponding to the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_dataStreams']={syn:'Builds a list of all data streams hold by the data logger.',lib:'datalogger&rarr;get_dataStreams()',pro:'int get_dataStreams()',cmt:'<p>Builds a list of all data streams hold by the data logger. The caller must pass by reference an empty array to hold YDataStream objects, and the function fills it with objects describing available data sequences.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'datalogger&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['DataLogger']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'datalogger&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['DataLogger']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'datalogger&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DataLogger']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'datalogger&rarr;get_dataloggerDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DataLogger']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'datalogger&rarr;get_dataloggerId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DataLogger']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'datalogger&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataLogger']['get_logicalName']={syn:'Returns the logical name of the data logger.',lib:'datalogger&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the data logger.</p>',ret:'a string corresponding to the logical name of the data logger',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DataLogger']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'datalogger&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DataLogger']['get_oldestRunIndex']={syn:'Returns the index of the oldest run for which the non-volatile memory still holds recorded data.',lib:'datalogger&rarr;get_oldestRunIndex()',pro:'unsigned get_oldestRunIndex()',cmt:'<p>Returns the index of the oldest run for which the non-volatile memory still holds recorded data.</p>',ret:'an integer corresponding to the index of the oldest run for which the non-volatile memory still holds recorded data',ext:'On failure, throws an exception or returns <tt>Y_OLDESTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_recording']={syn:'Returns the current activation state of the data logger.',lib:'datalogger&rarr;get_recording()',pro:'Y_RECORDING_enum get_recording()',cmt:'<p>Returns the current activation state of the data logger.</p>',ret:'either <tt>Y_RECORDING_OFF</tt> or <tt>Y_RECORDING_ON</tt>, according to the current activation state of the data logger',ext:'On failure, throws an exception or returns <tt>Y_RECORDING_INVALID</tt>.'};
doc['DataLogger']['get_timeUTC']={syn:'Returns the Unix timestamp for current UTC time, if known.',lib:'datalogger&rarr;get_timeUTC()',pro:'unsigned get_timeUTC()',cmt:'<p>Returns the Unix timestamp for current UTC time, if known.</p>',ret:'an integer corresponding to the Unix timestamp for current UTC time, if known',ext:'On failure, throws an exception or returns <tt>Y_TIMEUTC_INVALID</tt>.'};
doc['DataLogger']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'datalogger&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DataLogger']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'datalogger&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['DataLogger']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'datalogger&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['nextDataLogger']={syn:'Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.',lib:'datalogger&rarr;nextDataLogger()',pro:'YDataLogger * nextDataLogger()',cmt:'<p>Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to a data logger currently online, or a <tt>null</tt> pointer if there are no more data loggers to enumerate.'};
doc['DataLogger']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'datalogger&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DataLogger']['set_autoStart']={syn:'Changes the default activation state of the data logger on power up.',lib:'datalogger&rarr;set_autoStart()',pro:'int set_autoStart(Y_AUTOSTART_enum <span id=pn>newval</span>)',cmt:'<p>Changes the default activation state of the data logger on power up. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_logicalName']={syn:'Changes the logical name of the data logger.',lib:'datalogger&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the data logger. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the data logger'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_recording']={syn:'Changes the activation state of the data logger to start/stop recording data.',lib:'datalogger&rarr;set_recording()',pro:'int set_recording(Y_RECORDING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the data logger to start/stop recording data.</p>',par:{newval:'either <tt>Y_RECORDING_OFF</tt> or <tt>Y_RECORDING_ON</tt>, according to the activation state of the data logger to start/stop recording data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_timeUTC']={syn:'Changes the current UTC time reference used for recorded data.',lib:'datalogger&rarr;set_timeUTC()',pro:'int set_timeUTC(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the current UTC time reference used for recorded data.</p>',par:{newval:'an integer corresponding to the current UTC time reference used for recorded data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'datalogger&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: DataLogger)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'External power supply control interface',inc:'#include &quot;yocto_dualpower.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you to control the power source to use for module functions that require high current. The module can also automatically disconnect the external power when a voltage drop is observed on the external power source (external battery running out of power).</p>'}};
doc['DualPower']['FindDualPower']={syn:'Retrieves a dual power control for a given identifier.',lib:'YDualPower::FindDualPower()',pro:'YDualPower* FindDualPower(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a dual power control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the power control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDualPower.isOnline()</tt> to test if the power control is indeed online at a given time. In case of ambiguity when looking for a dual power control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the power control'},ret:'a <tt>YDualPower</tt> object allowing you to drive the power control.'};
doc['DualPower']['FirstDualPower']={syn:'Starts the enumeration of dual power controls currently accessible.',lib:'YDualPower::FirstDualPower()',pro:'YDualPower* FirstDualPower()',cmt:'<p>Starts the enumeration of dual power controls currently accessible. Use the method <tt>YDualPower.nextDualPower()</tt> to iterate on next dual power controls.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to the first dual power control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DualPower']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'dualpower&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DualPower']['get_advertisedValue']={syn:'Returns the current value of the power control (no more than 6 characters).',lib:'dualpower&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the power control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power control (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DualPower']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'dualpower&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['DualPower']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'dualpower&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['DualPower']['get_extVoltage']={syn:'Returns the measured voltage on the external power source, in millivolts.',lib:'dualpower&rarr;get_extVoltage()',pro:'unsigned get_extVoltage()',cmt:'<p>Returns the measured voltage on the external power source, in millivolts.</p>',ret:'an integer corresponding to the measured voltage on the external power source, in millivolts',ext:'On failure, throws an exception or returns <tt>Y_EXTVOLTAGE_INVALID</tt>.'};
doc['DualPower']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'dualpower&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DualPower']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'dualpower&rarr;get_dualpowerDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DualPower']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'dualpower&rarr;get_dualpowerId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DualPower']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'dualpower&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DualPower']['get_logicalName']={syn:'Returns the logical name of the power control.',lib:'dualpower&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the power control.</p>',ret:'a string corresponding to the logical name of the power control',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DualPower']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'dualpower&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DualPower']['get_powerControl']={syn:'Returns the selected power source for module functions that require lots of current.',lib:'dualpower&rarr;get_powerControl()',pro:'Y_POWERCONTROL_enum get_powerControl()',cmt:'<p>Returns the selected power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERCONTROL_INVALID</tt>.'};
doc['DualPower']['get_powerState']={syn:'Returns the current power source for module functions that require lots of current.',lib:'dualpower&rarr;get_powerState()',pro:'Y_POWERSTATE_enum get_powerState()',cmt:'<p>Returns the current power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERSTATE_OFF</tt>, <tt>Y_POWERSTATE_FROM_USB</tt> and <tt>Y_POWERSTATE_FROM_EXT</tt> corresponding to the current power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['DualPower']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'dualpower&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DualPower']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'dualpower&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['DualPower']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'dualpower&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['nextDualPower']={syn:'Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>.',lib:'dualpower&rarr;nextDualPower()',pro:'YDualPower * nextDualPower()',cmt:'<p>Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to a dual power control currently online, or a <tt>null</tt> pointer if there are no more dual power controls to enumerate.'};
doc['DualPower']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'dualpower&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DualPower']['set_logicalName']={syn:'Changes the logical name of the power control.',lib:'dualpower&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the power control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the power control'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_powerControl']={syn:'Changes the selected power source for module functions that require lots of current.',lib:'dualpower&rarr;set_powerControl()',pro:'int set_powerControl(Y_POWERCONTROL_enum <span id=pn>newval</span>)',cmt:'<p>Changes the selected power source for module functions that require lots of current.</p>',par:{newval:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'dualpower&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: DualPower)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Servo function interface',inc:'#include &quot;yocto_servo.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you not only to move a servo to a given position, but also to specify the time interval in which the move should be performed. This makes it possible to synchronize two servos involved in a same move.</p>'}};
doc['Servo']['FindServo']={syn:'Retrieves a servo for a given identifier.',lib:'YServo::FindServo()',pro:'YServo* FindServo(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a servo for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the servo is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YServo.isOnline()</tt> to test if the servo is indeed online at a given time. In case of ambiguity when looking for a servo by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the servo'},ret:'a <tt>YServo</tt> object allowing you to drive the servo.'};
doc['Servo']['FirstServo']={syn:'Starts the enumeration of servos currently accessible.',lib:'YServo::FirstServo()',pro:'YServo* FirstServo()',cmt:'<p>Starts the enumeration of servos currently accessible. Use the method <tt>YServo.nextServo()</tt> to iterate on next servos.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to the first servo currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Servo']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'servo&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Servo']['get_advertisedValue']={syn:'Returns the current value of the servo (no more than 6 characters).',lib:'servo&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the servo (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the servo (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Servo']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'servo&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Servo']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'servo&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Servo']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'servo&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Servo']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'servo&rarr;get_servoDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Servo']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'servo&rarr;get_servoId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Servo']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'servo&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Servo']['get_logicalName']={syn:'Returns the logical name of the servo.',lib:'servo&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the servo.</p>',ret:'a string corresponding to the logical name of the servo',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Servo']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'servo&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Servo']['get_neutral']={syn:'Returns the duration in microseconds of a neutral pulse for the servo.',lib:'servo&rarr;get_neutral()',pro:'int get_neutral()',cmt:'<p>Returns the duration in microseconds of a neutral pulse for the servo.</p>',ret:'an integer corresponding to the duration in microseconds of a neutral pulse for the servo',ext:'On failure, throws an exception or returns <tt>Y_NEUTRAL_INVALID</tt>.'};
doc['Servo']['get_position']={syn:'Returns the current servo position.',lib:'servo&rarr;get_position()',pro:'int get_position()',cmt:'<p>Returns the current servo position.</p>',ret:'an integer corresponding to the current servo position',ext:'On failure, throws an exception or returns <tt>Y_POSITION_INVALID</tt>.'};
doc['Servo']['get_range']={syn:'Returns the current range of use of the servo.',lib:'servo&rarr;get_range()',pro:'int get_range()',cmt:'<p>Returns the current range of use of the servo.</p>',ret:'an integer corresponding to the current range of use of the servo',ext:'On failure, throws an exception or returns <tt>Y_RANGE_INVALID</tt>.'};
doc['Servo']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'servo&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Servo']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'servo&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Servo']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'servo&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Servo']['move']={syn:'Performs a smooth move at constant speed toward a given position.',lib:'servo&rarr;move()',pro:'int move(int <span id=pn>target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given position.</p>',par:{target:'new position at the end of the move',ms_duration:'total duration of the move, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['nextServo']={syn:'Continues the enumeration of servos started using <tt>yFirstServo()</tt>.',lib:'servo&rarr;nextServo()',pro:'YServo * nextServo()',cmt:'<p>Continues the enumeration of servos started using <tt>yFirstServo()</tt>.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to a servo currently online, or a <tt>null</tt> pointer if there are no more servos to enumerate.'};
doc['Servo']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'servo&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Servo']['set_logicalName']={syn:'Changes the logical name of the servo.',lib:'servo&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the servo. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the servo'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_neutral']={syn:'Changes the duration of the pulse corresponding to the neutral position of the servo.',lib:'servo&rarr;set_neutral()',pro:'int set_neutral(int <span id=pn>newval</span>)',cmt:'<p>Changes the duration of the pulse corresponding to the neutral position of the servo. The duration is specified in microseconds, and the standard value is 1500 [us]. This setting makes it possible to shift the range of use of the servo. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the duration of the pulse corresponding to the neutral position of the servo'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_position']={syn:'Changes immediately the servo driving position.',lib:'servo&rarr;set_position()',pro:'int set_position(int <span id=pn>newval</span>)',cmt:'<p>Changes immediately the servo driving position.</p>',par:{newval:'an integer corresponding to immediately the servo driving position'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_range']={syn:'Changes the range of use of the servo, specified in per cents.',lib:'servo&rarr;set_range()',pro:'int set_range(int <span id=pn>newval</span>)',cmt:'<p>Changes the range of use of the servo, specified in per cents. A range of 100% corresponds to a standard control signal, that varies from 1 [ms] to 2 [ms], When using a servo that supports a double range, from 0.5 [ms] to 2.5 [ms], you can select a range of 200%. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the range of use of the servo, specified in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'servo&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Servo)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Relay function interface',inc:'#include &quot;yocto_relay.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to switch the relay state. This change is not persistent: the relay will automatically return to its idle position whenever power is lost or if the module is restarted. The library can also generate automatically short pulses of determined duration. On devices with two output for each relay (double throw), the two outputs are named A and B, with output A corresponding to the idle position (at power off) and the output B corresponding to the active state. If you prefer the alternate default state, simply switch your cables on the board.</p>'}};
doc['Relay']['FindRelay']={syn:'Retrieves a relay for a given identifier.',lib:'YRelay::FindRelay()',pro:'YRelay* FindRelay(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a relay for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the relay is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRelay.isOnline()</tt> to test if the relay is indeed online at a given time. In case of ambiguity when looking for a relay by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the relay'},ret:'a <tt>YRelay</tt> object allowing you to drive the relay.'};
doc['Relay']['FirstRelay']={syn:'Starts the enumeration of relays currently accessible.',lib:'YRelay::FirstRelay()',pro:'YRelay* FirstRelay()',cmt:'<p>Starts the enumeration of relays currently accessible. Use the method <tt>YRelay.nextRelay()</tt> to iterate on next relays.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to the first relay currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Relay']['delayedPulse']={syn:'Schedules a pulse.',lib:'relay&rarr;delayedPulse()',pro:'int delayedPulse(int <span id=pn>ms_delay</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'relay&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Relay']['get_advertisedValue']={syn:'Returns the current value of the relay (no more than 6 characters).',lib:'relay&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the relay (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the relay (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Relay']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'relay&rarr;get_countdown()',pro:'unsigned get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Relay']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'relay&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Relay']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'relay&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Relay']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'relay&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Relay']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'relay&rarr;get_relayDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Relay']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'relay&rarr;get_relayId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Relay']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'relay&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Relay']['get_logicalName']={syn:'Returns the logical name of the relay.',lib:'relay&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the relay.</p>',ret:'a string corresponding to the logical name of the relay',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Relay']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'relay&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Relay']['get_output']={syn:'Returns the output state of the relays, when used as a simple switch (single throw).',lib:'relay&rarr;get_output()',pro:'Y_OUTPUT_enum get_output()',cmt:'<p>Returns the output state of the relays, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Relay']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation.',lib:'relay&rarr;get_pulseTimer()',pro:'unsigned get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Relay']['get_state']={syn:'Returns the state of the relays (A for the idle position, B for the active position).',lib:'relay&rarr;get_state()',pro:'Y_STATE_enum get_state()',cmt:'<p>Returns the state of the relays (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Relay']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'relay&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Relay']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'relay&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Relay']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'relay&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Relay']['nextRelay']={syn:'Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.',lib:'relay&rarr;nextRelay()',pro:'YRelay * nextRelay()',cmt:'<p>Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to a relay currently online, or a <tt>null</tt> pointer if there are no more relays to enumerate.'};
doc['Relay']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'relay&rarr;pulse()',pro:'int pulse(int <span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'relay&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Relay']['set_logicalName']={syn:'Changes the logical name of the relay.',lib:'relay&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the relay. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the relay'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_output']={syn:'Changes the output state of the relays, when used as a simple switch (single throw).',lib:'relay&rarr;set_output()',pro:'int set_output(Y_OUTPUT_enum <span id=pn>newval</span>)',cmt:'<p>Changes the output state of the relays, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_state']={syn:'Changes the state of the relays (A for the idle position, B for the active position).',lib:'relay&rarr;set_state()',pro:'int set_state(Y_STATE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the relays (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'relay&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Relay)
//--- (generated code: Led)
doc['Led']={'':{syn:'Led function interface',inc:'#include &quot;yocto_led.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you not only to drive the intensity of the led, but also to have it blink at various preset frequencies.</p>'}};
doc['Led']['FindLed']={syn:'Retrieves a led for a given identifier.',lib:'YLed::FindLed()',pro:'YLed* FindLed(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a led for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the led is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLed.isOnline()</tt> to test if the led is indeed online at a given time. In case of ambiguity when looking for a led by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the led'},ret:'a <tt>YLed</tt> object allowing you to drive the led.'};
doc['Led']['FirstLed']={syn:'Starts the enumeration of leds currently accessible.',lib:'YLed::FirstLed()',pro:'YLed* FirstLed()',cmt:'<p>Starts the enumeration of leds currently accessible. Use the method <tt>YLed.nextLed()</tt> to iterate on next leds.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to the first led currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Led']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'led&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Led']['get_advertisedValue']={syn:'Returns the current value of the led (no more than 6 characters).',lib:'led&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the led (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the led (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Led']['get_blinking']={syn:'Returns the current led signaling mode.',lib:'led&rarr;get_blinking()',pro:'Y_BLINKING_enum get_blinking()',cmt:'<p>Returns the current led signaling mode.</p>',ret:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current led signaling mode',ext:'On failure, throws an exception or returns <tt>Y_BLINKING_INVALID</tt>.'};
doc['Led']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'led&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Led']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'led&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Led']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'led&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Led']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'led&rarr;get_ledDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Led']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'led&rarr;get_ledId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Led']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'led&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Led']['get_logicalName']={syn:'Returns the logical name of the led.',lib:'led&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the led.</p>',ret:'a string corresponding to the logical name of the led',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Led']['get_luminosity']={syn:'Returns the current led intensity (in per cent).',lib:'led&rarr;get_luminosity()',pro:'int get_luminosity()',cmt:'<p>Returns the current led intensity (in per cent).</p>',ret:'an integer corresponding to the current led intensity (in per cent)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Led']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'led&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Led']['get_power']={syn:'Returns the current led state.',lib:'led&rarr;get_power()',pro:'Y_POWER_enum get_power()',cmt:'<p>Returns the current led state.</p>',ret:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the current led state',ext:'On failure, throws an exception or returns <tt>Y_POWER_INVALID</tt>.'};
doc['Led']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'led&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Led']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'led&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Led']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'led&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Led']['nextLed']={syn:'Continues the enumeration of leds started using <tt>yFirstLed()</tt>.',lib:'led&rarr;nextLed()',pro:'YLed * nextLed()',cmt:'<p>Continues the enumeration of leds started using <tt>yFirstLed()</tt>.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to a led currently online, or a <tt>null</tt> pointer if there are no more leds to enumerate.'};
doc['Led']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'led&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Led']['set_blinking']={syn:'Changes the current led signaling mode.',lib:'led&rarr;set_blinking()',pro:'int set_blinking(Y_BLINKING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the current led signaling mode.</p>',par:{newval:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current led signaling mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_logicalName']={syn:'Changes the logical name of the led.',lib:'led&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the led. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the led'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_luminosity']={syn:'Changes the current led intensity (in per cent).',lib:'led&rarr;set_luminosity()',pro:'int set_luminosity(int <span id=pn>newval</span>)',cmt:'<p>Changes the current led intensity (in per cent).</p>',par:{newval:'an integer corresponding to the current led intensity (in per cent)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_power']={syn:'Changes the state of the led.',lib:'led&rarr;set_power()',pro:'int set_power(Y_POWER_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the led.</p>',par:{newval:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the state of the led'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'led&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Led)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Humidity function interface',inc:'#include &quot;yocto_humidity.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Humidity']['FindHumidity']={syn:'Retrieves a humidity sensor for a given identifier.',lib:'YHumidity::FindHumidity()',pro:'YHumidity* FindHumidity(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a humidity sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the humidity sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHumidity.isOnline()</tt> to test if the humidity sensor is indeed online at a given time. In case of ambiguity when looking for a humidity sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the humidity sensor'},ret:'a <tt>YHumidity</tt> object allowing you to drive the humidity sensor.'};
doc['Humidity']['FirstHumidity']={syn:'Starts the enumeration of humidity sensors currently accessible.',lib:'YHumidity::FirstHumidity()',pro:'YHumidity* FirstHumidity()',cmt:'<p>Starts the enumeration of humidity sensors currently accessible. Use the method <tt>YHumidity.nextHumidity()</tt> to iterate on next humidity sensors.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to the first humidity sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Humidity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'humidity&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a lineat interpolatation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'humidity&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Humidity']['get_advertisedValue']={syn:'Returns the current value of the humidity sensor (no more than 6 characters).',lib:'humidity&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the humidity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the humidity sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentRawValue']={syn:'Returns the unrounded and uncalibrated raw value returned by the sensor.',lib:'humidity&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the unrounded and uncalibrated raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the unrounded and uncalibrated raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentValue']={syn:'Returns the current measured value.',lib:'humidity&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Humidity']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'humidity&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Humidity']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'humidity&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Humidity']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'humidity&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Humidity']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'humidity&rarr;get_humidityDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Humidity']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'humidity&rarr;get_humidityId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Humidity']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'humidity&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Humidity']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'humidity&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_logicalName']={syn:'Returns the logical name of the humidity sensor.',lib:'humidity&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the humidity sensor.</p>',ret:'a string corresponding to the logical name of the humidity sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Humidity']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'humidity&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'humidity&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Humidity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'humidity&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Humidity']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'humidity&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Humidity']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'humidity&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Humidity']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'humidity&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Humidity']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'humidity&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['nextHumidity']={syn:'Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.',lib:'humidity&rarr;nextHumidity()',pro:'YHumidity * nextHumidity()',cmt:'<p>Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to a humidity sensor currently online, or a <tt>null</tt> pointer if there are no more humidity sensors to enumerate.'};
doc['Humidity']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'humidity&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Humidity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'humidity&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_logicalName']={syn:'Changes the logical name of the humidity sensor.',lib:'humidity&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the humidity sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the humidity sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'humidity&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'humidity&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Humidity)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Pressure function interface',inc:'#include &quot;yocto_pressure.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Pressure']['FindPressure']={syn:'Retrieves a pressure sensor for a given identifier.',lib:'YPressure::FindPressure()',pro:'YPressure* FindPressure(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a pressure sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the pressure sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPressure.isOnline()</tt> to test if the pressure sensor is indeed online at a given time. In case of ambiguity when looking for a pressure sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the pressure sensor'},ret:'a <tt>YPressure</tt> object allowing you to drive the pressure sensor.'};
doc['Pressure']['FirstPressure']={syn:'Starts the enumeration of pressure sensors currently accessible.',lib:'YPressure::FirstPressure()',pro:'YPressure* FirstPressure()',cmt:'<p>Starts the enumeration of pressure sensors currently accessible. Use the method <tt>YPressure.nextPressure()</tt> to iterate on next pressure sensors.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to the first pressure sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Pressure']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'pressure&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a lineat interpolatation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pressure&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Pressure']['get_advertisedValue']={syn:'Returns the current value of the pressure sensor (no more than 6 characters).',lib:'pressure&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the pressure sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the pressure sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentRawValue']={syn:'Returns the unrounded and uncalibrated raw value returned by the sensor.',lib:'pressure&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the unrounded and uncalibrated raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the unrounded and uncalibrated raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentValue']={syn:'Returns the current measured value.',lib:'pressure&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Pressure']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'pressure&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Pressure']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'pressure&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Pressure']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pressure&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Pressure']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pressure&rarr;get_pressureDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Pressure']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'pressure&rarr;get_pressureId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Pressure']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'pressure&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Pressure']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'pressure&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_logicalName']={syn:'Returns the logical name of the pressure sensor.',lib:'pressure&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the pressure sensor.</p>',ret:'a string corresponding to the logical name of the pressure sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Pressure']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'pressure&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pressure&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Pressure']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'pressure&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Pressure']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'pressure&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Pressure']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pressure&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Pressure']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'pressure&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Pressure']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'pressure&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['nextPressure']={syn:'Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.',lib:'pressure&rarr;nextPressure()',pro:'YPressure * nextPressure()',cmt:'<p>Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to a pressure sensor currently online, or a <tt>null</tt> pointer if there are no more pressure sensors to enumerate.'};
doc['Pressure']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pressure&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Pressure']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'pressure&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_logicalName']={syn:'Changes the logical name of the pressure sensor.',lib:'pressure&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the pressure sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the pressure sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'pressure&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pressure&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Pressure)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'LightSensor function interface',inc:'#include &quot;yocto_lightsensor.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['LightSensor']['FindLightSensor']={syn:'Retrieves a light sensor for a given identifier.',lib:'YLightSensor::FindLightSensor()',pro:'YLightSensor* FindLightSensor(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a light sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the light sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLightSensor.isOnline()</tt> to test if the light sensor is indeed online at a given time. In case of ambiguity when looking for a light sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the light sensor'},ret:'a <tt>YLightSensor</tt> object allowing you to drive the light sensor.'};
doc['LightSensor']['FirstLightSensor']={syn:'Starts the enumeration of light sensors currently accessible.',lib:'YLightSensor::FirstLightSensor()',pro:'YLightSensor* FirstLightSensor()',cmt:'<p>Starts the enumeration of light sensors currently accessible. Use the method <tt>YLightSensor.nextLightSensor()</tt> to iterate on next light sensors.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to the first light sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['LightSensor']['calibrate']={syn:'Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).',lib:'lightsensor&rarr;calibrate()',pro:'int calibrate(double <span id=pn>calibratedVal</span>)',cmt:'<p>Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).</p>',par:{calibratedVal:'the desired target value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'lightsensor&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a lineat interpolatation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'lightsensor&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['LightSensor']['get_advertisedValue']={syn:'Returns the current value of the light sensor (no more than 6 characters).',lib:'lightsensor&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the light sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the light sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentRawValue']={syn:'Returns the unrounded and uncalibrated raw value returned by the sensor.',lib:'lightsensor&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the unrounded and uncalibrated raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the unrounded and uncalibrated raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentValue']={syn:'Returns the current measured value.',lib:'lightsensor&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'lightsensor&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['LightSensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'lightsensor&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['LightSensor']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'lightsensor&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['LightSensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'lightsensor&rarr;get_lightsensorDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['LightSensor']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'lightsensor&rarr;get_lightsensorId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['LightSensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'lightsensor&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['LightSensor']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'lightsensor&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_logicalName']={syn:'Returns the logical name of the light sensor.',lib:'lightsensor&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the light sensor.</p>',ret:'a string corresponding to the logical name of the light sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['LightSensor']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'lightsensor&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'lightsensor&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['LightSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'lightsensor&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['LightSensor']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'lightsensor&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['LightSensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'lightsensor&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['LightSensor']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'lightsensor&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['LightSensor']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'lightsensor&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['nextLightSensor']={syn:'Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.',lib:'lightsensor&rarr;nextLightSensor()',pro:'YLightSensor * nextLightSensor()',cmt:'<p>Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to a light sensor currently online, or a <tt>null</tt> pointer if there are no more light sensors to enumerate.'};
doc['LightSensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'lightsensor&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['LightSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'lightsensor&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_logicalName']={syn:'Changes the logical name of the light sensor.',lib:'lightsensor&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the light sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the light sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'lightsensor&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'lightsensor&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: LightSensor)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'ColorLed function interface',inc:'#include &quot;yocto_colorled.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you to drive a color led using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a led with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLed']['FindColorLed']={syn:'Retrieves an RGB led for a given identifier.',lib:'YColorLed::FindColorLed()',pro:'YColorLed* FindColorLed(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves an RGB led for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the RGB led is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorLed.isOnline()</tt> to test if the RGB led is indeed online at a given time. In case of ambiguity when looking for an RGB led by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the RGB led'},ret:'a <tt>YColorLed</tt> object allowing you to drive the RGB led.'};
doc['ColorLed']['FirstColorLed']={syn:'Starts the enumeration of RGB leds currently accessible.',lib:'YColorLed::FirstColorLed()',pro:'YColorLed* FirstColorLed()',cmt:'<p>Starts the enumeration of RGB leds currently accessible. Use the method <tt>YColorLed.nextColorLed()</tt> to iterate on next RGB leds.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to the first RGB led currently online, or a <tt>null</tt> pointer if there are none.'};
doc['ColorLed']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'colorled&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['ColorLed']['get_advertisedValue']={syn:'Returns the current value of the RGB led (no more than 6 characters).',lib:'colorled&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the RGB led (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB led (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLed']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'colorled&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['ColorLed']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'colorled&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['ColorLed']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'colorled&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['ColorLed']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'colorled&rarr;get_colorledDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['ColorLed']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'colorled&rarr;get_colorledId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['ColorLed']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'colorled&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['ColorLed']['get_hslColor']={syn:'Returns the current HSL color of the led.',lib:'colorled&rarr;get_hslColor()',pro:'unsigned get_hslColor()',cmt:'<p>Returns the current HSL color of the led.</p>',ret:'an integer corresponding to the current HSL color of the led',ext:'On failure, throws an exception or returns <tt>Y_HSLCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_logicalName']={syn:'Returns the logical name of the RGB led.',lib:'colorled&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the RGB led.</p>',ret:'a string corresponding to the logical name of the RGB led',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLed']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'colorled&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['ColorLed']['get_rgbColor']={syn:'Returns the current RGB color of the led.',lib:'colorled&rarr;get_rgbColor()',pro:'unsigned get_rgbColor()',cmt:'<p>Returns the current RGB color of the led.</p>',ret:'an integer corresponding to the current RGB color of the led',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Returns the configured color to be displayed when the module is turned on.',lib:'colorled&rarr;get_rgbColorAtPowerOn()',pro:'unsigned get_rgbColorAtPowerOn()',cmt:'<p>Returns the configured color to be displayed when the module is turned on.</p>',ret:'an integer corresponding to the configured color to be displayed when the module is turned on',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLORATPOWERON_INVALID</tt>.'};
doc['ColorLed']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'colorled&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['ColorLed']['hslMove']={syn:'Performs a smooth transition in the HSL color space between the current color and a target color.',lib:'colorled&rarr;hslMove()',pro:'int hslMove(int <span id=pn>hsl_target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the HSL color space between the current color and a target color.</p>',par:{hsl_target:'desired HSL color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'colorled&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['ColorLed']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'colorled&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['nextColorLed']={syn:'Continues the enumeration of RGB leds started using <tt>yFirstColorLed()</tt>.',lib:'colorled&rarr;nextColorLed()',pro:'YColorLed * nextColorLed()',cmt:'<p>Continues the enumeration of RGB leds started using <tt>yFirstColorLed()</tt>.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to an RGB led currently online, or a <tt>null</tt> pointer if there are no more RGB leds to enumerate.'};
doc['ColorLed']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'colorled&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['ColorLed']['rgbMove']={syn:'Performs a smooth transition in the RGB color space between the current color and a target color.',lib:'colorled&rarr;rgbMove()',pro:'int rgbMove(int <span id=pn>rgb_target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the RGB color space between the current color and a target color.</p>',par:{rgb_target:'desired RGB color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_hslColor']={syn:'Changes the current color of the led, using a color HSL.',lib:'colorled&rarr;set_hslColor()',pro:'int set_hslColor(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the current color of the led, using a color HSL. Encoding is done as follows: 0xHHSSLL.</p>',par:{newval:'an integer corresponding to the current color of the led, using a color HSL'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_logicalName']={syn:'Changes the logical name of the RGB led.',lib:'colorled&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RGB led. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RGB led'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColor']={syn:'Changes the current color of the led, using a RGB color.',lib:'colorled&rarr;set_rgbColor()',pro:'int set_rgbColor(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the current color of the led, using a RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{newval:'an integer corresponding to the current color of the led, using a RGB color'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Changes the color that the led will display by default when the module is turned on.',lib:'colorled&rarr;set_rgbColorAtPowerOn()',pro:'int set_rgbColorAtPowerOn(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the color that the led will display by default when the module is turned on. This color will be displayed as soon as the module is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the change should be kept.</p>',par:{newval:'an integer corresponding to the color that the led will display by default when the module is turned on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'colorled&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: ColorLed)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Yocto-hub port interface',inc:'#include &quot;yocto_hubport.h&quot;'}};
doc['HubPort']['FindHubPort']={syn:'Retrieves a Yocto-hub port for a given identifier.',lib:'YHubPort::FindHubPort()',pro:'YHubPort* FindHubPort(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a Yocto-hub port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the Yocto-hub port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHubPort.isOnline()</tt> to test if the Yocto-hub port is indeed online at a given time. In case of ambiguity when looking for a Yocto-hub port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the Yocto-hub port'},ret:'a <tt>YHubPort</tt> object allowing you to drive the Yocto-hub port.'};
doc['HubPort']['FirstHubPort']={syn:'Starts the enumeration of Yocto-hub ports currently accessible.',lib:'YHubPort::FirstHubPort()',pro:'YHubPort* FirstHubPort()',cmt:'<p>Starts the enumeration of Yocto-hub ports currently accessible. Use the method <tt>YHubPort.nextHubPort()</tt> to iterate on next Yocto-hub ports.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to the first Yocto-hub port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['HubPort']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'hubport&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['HubPort']['get_advertisedValue']={syn:'Returns the current value of the Yocto-hub port (no more than 6 characters).',lib:'hubport&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the Yocto-hub port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Yocto-hub port (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['HubPort']['get_baudRate']={syn:'Returns the current baud rate used by this Yocto-hub port, in kbps.',lib:'hubport&rarr;get_baudRate()',pro:'int get_baudRate()',cmt:'<p>Returns the current baud rate used by this Yocto-hub port, in kbps. The default value is 1000 kbps, but a slower rate may be used if communication problems are hit.</p>',ret:'an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps',ext:'On failure, throws an exception or returns <tt>Y_BAUDRATE_INVALID</tt>.'};
doc['HubPort']['get_enabled']={syn:'Returns true if the Yocto-hub port is powered, false otherwise.',lib:'hubport&rarr;get_enabled()',pro:'Y_ENABLED_enum get_enabled()',cmt:'<p>Returns true if the Yocto-hub port is powered, false otherwise.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to true if the Yocto-hub port is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['HubPort']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'hubport&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['HubPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'hubport&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['HubPort']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'hubport&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['HubPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'hubport&rarr;get_hubportDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['HubPort']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'hubport&rarr;get_hubportId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['HubPort']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'hubport&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['HubPort']['get_logicalName']={syn:'Returns the logical name of the Yocto-hub port, which is always the serial number of the connected module.',lib:'hubport&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the Yocto-hub port, which is always the serial number of the connected module.</p>',ret:'a string corresponding to the logical name of the Yocto-hub port, which is always the serial number of the connected module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['HubPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'hubport&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['HubPort']['get_portState']={syn:'Returns the current state of the Yocto-hub port.',lib:'hubport&rarr;get_portState()',pro:'Y_PORTSTATE_enum get_portState()',cmt:'<p>Returns the current state of the Yocto-hub port.</p>',ret:'a value among <tt>Y_PORTSTATE_OFF</tt>, <tt>Y_PORTSTATE_ON</tt> and <tt>Y_PORTSTATE_RUN</tt> corresponding to the current state of the Yocto-hub port',ext:'On failure, throws an exception or returns <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['HubPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'hubport&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['HubPort']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'hubport&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['HubPort']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'hubport&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['nextHubPort']={syn:'Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>.',lib:'hubport&rarr;nextHubPort()',pro:'YHubPort * nextHubPort()',cmt:'<p>Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to a Yocto-hub port currently online, or a <tt>null</tt> pointer if there are no more Yocto-hub ports to enumerate.'};
doc['HubPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'hubport&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['HubPort']['set_enabled']={syn:'Changes the activation of the Yocto-hub port.',lib:'hubport&rarr;set_enabled()',pro:'int set_enabled(Y_ENABLED_enum <span id=pn>newval</span>)',cmt:'<p>Changes the activation of the Yocto-hub port. If the port is enabled, the * connected module will be powered. Otherwise, port power will be shut down.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the activation of the Yocto-hub port'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_logicalName']={syn:'It is not possible to configure the logical name of a Yocto-hub port.',lib:'hubport&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>It is not possible to configure the logical name of a Yocto-hub port. The logical name is automatically set to the serial number of the connected module.</p>',par:{newval:'a string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'hubport&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: HubPort)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'AnButton function interface',inc:'#include &quot;yocto_anbutton.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you to measure the state of a simple button as well as to read an analog potentiometer (variable resistance). This can be use for instance with a continuous rotating knob, a throttle grip or a joystick. The module is capable to calibrate itself on min and max values, in order to compute a calibrated value that varies proportionally with the potentiometer position, regardless of its total resistance.</p>'}};
doc['AnButton']['FindAnButton']={syn:'Retrieves an analog input for a given identifier.',lib:'YAnButton::FindAnButton()',pro:'YAnButton* FindAnButton(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves an analog input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the analog input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAnButton.isOnline()</tt> to test if the analog input is indeed online at a given time. In case of ambiguity when looking for an analog input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the analog input'},ret:'a <tt>YAnButton</tt> object allowing you to drive the analog input.'};
doc['AnButton']['FirstAnButton']={syn:'Starts the enumeration of analog inputs currently accessible.',lib:'YAnButton::FirstAnButton()',pro:'YAnButton* FirstAnButton()',cmt:'<p>Starts the enumeration of analog inputs currently accessible. Use the method <tt>YAnButton.nextAnButton()</tt> to iterate on next analog inputs.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to the first analog input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['AnButton']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'anbutton&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AnButton']['get_advertisedValue']={syn:'Returns the current value of the analog input (no more than 6 characters).',lib:'anbutton&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the analog input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the analog input (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_analogCalibration']={syn:'Tells if a calibration process is currently ongoing.',lib:'anbutton&rarr;get_analogCalibration()',pro:'Y_ANALOGCALIBRATION_enum get_analogCalibration()',cmt:'<p>Tells if a calibration process is currently ongoing.</p>',ret:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>',ext:'On failure, throws an exception or returns <tt>Y_ANALOGCALIBRATION_INVALID</tt>.'};
doc['AnButton']['get_calibratedValue']={syn:'Returns the current calibrated input value (between 0 and 1000, included).',lib:'anbutton&rarr;get_calibratedValue()',pro:'unsigned get_calibratedValue()',cmt:'<p>Returns the current calibrated input value (between 0 and 1000, included).</p>',ret:'an integer corresponding to the current calibrated input value (between 0 and 1000, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_calibrationMax']={syn:'Returns the maximal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton&rarr;get_calibrationMax()',pro:'unsigned get_calibrationMax()',cmt:'<p>Returns the maximal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the maximal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMAX_INVALID</tt>.'};
doc['AnButton']['get_calibrationMin']={syn:'Returns the minimal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton&rarr;get_calibrationMin()',pro:'unsigned get_calibrationMin()',cmt:'<p>Returns the minimal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the minimal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMIN_INVALID</tt>.'};
doc['AnButton']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'anbutton&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['AnButton']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'anbutton&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['AnButton']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'anbutton&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AnButton']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'anbutton&rarr;get_anbuttonDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['AnButton']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'anbutton&rarr;get_anbuttonId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AnButton']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'anbutton&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AnButton']['get_isPressed']={syn:'Returns true if the input (considered as binary) is active (closed contact), and false otherwise.',lib:'anbutton&rarr;get_isPressed()',pro:'Y_ISPRESSED_enum get_isPressed()',cmt:'<p>Returns true if the input (considered as binary) is active (closed contact), and false otherwise.</p>',ret:'either <tt>Y_ISPRESSED_FALSE</tt> or <tt>Y_ISPRESSED_TRUE</tt>, according to true if the input (considered as binary) is active (closed contact), and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ISPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimePressed']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitionned from open to closed).',lib:'anbutton&rarr;get_lastTimePressed()',pro:'unsigned get_lastTimePressed()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitionned from open to closed).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitionned from open to closed)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMEPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimeReleased']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitionned from closed to open).',lib:'anbutton&rarr;get_lastTimeReleased()',pro:'unsigned get_lastTimeReleased()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitionned from closed to open).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitionned from closed to open)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMERELEASED_INVALID</tt>.'};
doc['AnButton']['get_logicalName']={syn:'Returns the logical name of the analog input.',lib:'anbutton&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the analog input.</p>',ret:'a string corresponding to the logical name of the analog input',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AnButton']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'anbutton&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['AnButton']['get_pulseCounter']={syn:'Returns the pulse counter value ',lib:'anbutton&rarr;get_pulseCounter()',pro:'unsigned get_pulseCounter()',cmt:'<p>Returns the pulse counter value</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['AnButton']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms) ',lib:'anbutton&rarr;get_pulseTimer()',pro:'unsigned get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms)</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['AnButton']['get_rawValue']={syn:'Returns the current measured input value as-is (between 0 and 4095, included).',lib:'anbutton&rarr;get_rawValue()',pro:'unsigned get_rawValue()',cmt:'<p>Returns the current measured input value as-is (between 0 and 4095, included).</p>',ret:'an integer corresponding to the current measured input value as-is (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_RAWVALUE_INVALID</tt>.'};
doc['AnButton']['get_sensitivity']={syn:'Returns the sensibility for the input (between 1 and 255, included) for triggering user callbacks.',lib:'anbutton&rarr;get_sensitivity()',pro:'unsigned get_sensitivity()',cmt:'<p>Returns the sensibility for the input (between 1 and 255, included) for triggering user callbacks.</p>',ret:'an integer corresponding to the sensibility for the input (between 1 and 255, included) for triggering user callbacks',ext:'On failure, throws an exception or returns <tt>Y_SENSITIVITY_INVALID</tt>.'};
doc['AnButton']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'anbutton&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['AnButton']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'anbutton&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['AnButton']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'anbutton&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['nextAnButton']={syn:'Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.',lib:'anbutton&rarr;nextAnButton()',pro:'YAnButton * nextAnButton()',cmt:'<p>Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to an analog input currently online, or a <tt>null</tt> pointer if there are no more analog inputs to enumerate.'};
doc['AnButton']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'anbutton&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['AnButton']['resetCounter']={syn:'Returns the pulse counter value as well as his timer ',lib:'anbutton&rarr;resetCounter()',pro:'int resetCounter()',cmt:'<p>Returns the pulse counter value as well as his timer</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_analogCalibration']={syn:'Starts or stops the calibration process.',lib:'anbutton&rarr;set_analogCalibration()',pro:'int set_analogCalibration(Y_ANALOGCALIBRATION_enum <span id=pn>newval</span>)',cmt:'<p>Starts or stops the calibration process. Remember to call the <tt>saveToFlash()</tt> method of the module at the end of the calibration if the modification must be kept.</p>',par:{newval:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMax']={syn:'Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton&rarr;set_calibrationMax()',pro:'int set_calibrationMax(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMin']={syn:'Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton&rarr;set_calibrationMin()',pro:'int set_calibrationMin(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_logicalName']={syn:'Changes the logical name of the analog input.',lib:'anbutton&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the analog input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the analog input'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_sensitivity']={syn:'Changes the sensibility for the input (between 1 and 255, included) for triggering user callbacks.',lib:'anbutton&rarr;set_sensitivity()',pro:'int set_sensitivity(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the sensibility for the input (between 1 and 255, included) for triggering user callbacks. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the sensibility for the input (between 1 and 255, included) for triggering user callbacks'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'anbutton&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: AnButton)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Voltage function interface',inc:'#include &quot;yocto_voltage.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Voltage']['FindVoltage']={syn:'Retrieves a voltage sensor for a given identifier.',lib:'YVoltage::FindVoltage()',pro:'YVoltage* FindVoltage(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a voltage sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the voltage sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoltage.isOnline()</tt> to test if the voltage sensor is indeed online at a given time. In case of ambiguity when looking for a voltage sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the voltage sensor'},ret:'a <tt>YVoltage</tt> object allowing you to drive the voltage sensor.'};
doc['Voltage']['FirstVoltage']={syn:'Starts the enumeration of voltage sensors currently accessible.',lib:'YVoltage::FirstVoltage()',pro:'YVoltage* FirstVoltage()',cmt:'<p>Starts the enumeration of voltage sensors currently accessible. Use the method <tt>YVoltage.nextVoltage()</tt> to iterate on next voltage sensors.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to the first voltage sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voltage']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voltage&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a lineat interpolatation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voltage&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voltage']['get_advertisedValue']={syn:'Returns the current value of the voltage sensor (no more than 6 characters).',lib:'voltage&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the voltage sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'voltage&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentValue']={syn:'Returns the current measured value.',lib:'voltage&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voltage']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'voltage&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Voltage']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'voltage&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Voltage']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voltage&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voltage']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voltage&rarr;get_voltageDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voltage']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'voltage&rarr;get_voltageId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voltage']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'voltage&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voltage']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'voltage&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_logicalName']={syn:'Returns the logical name of the voltage sensor.',lib:'voltage&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the voltage sensor.</p>',ret:'a string corresponding to the logical name of the voltage sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voltage']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'voltage&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voltage&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voltage']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voltage&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voltage']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'voltage&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voltage']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voltage&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voltage']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'voltage&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Voltage']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'voltage&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['nextVoltage']={syn:'Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.',lib:'voltage&rarr;nextVoltage()',pro:'YVoltage * nextVoltage()',cmt:'<p>Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to a voltage sensor currently online, or a <tt>null</tt> pointer if there are no more voltage sensors to enumerate.'};
doc['Voltage']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voltage&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voltage']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voltage&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_logicalName']={syn:'Changes the logical name of the voltage sensor.',lib:'voltage&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voltage&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voltage&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Voltage)
//--- (generated code: Current)
doc['Current']={'':{syn:'Current function interface',inc:'#include &quot;yocto_current.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Current']['FindCurrent']={syn:'Retrieves a current sensor for a given identifier.',lib:'YCurrent::FindCurrent()',pro:'YCurrent* FindCurrent(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a current sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the current sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCurrent.isOnline()</tt> to test if the current sensor is indeed online at a given time. In case of ambiguity when looking for a current sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the current sensor'},ret:'a <tt>YCurrent</tt> object allowing you to drive the current sensor.'};
doc['Current']['FirstCurrent']={syn:'Starts the enumeration of current sensors currently accessible.',lib:'YCurrent::FirstCurrent()',pro:'YCurrent* FirstCurrent()',cmt:'<p>Starts the enumeration of current sensors currently accessible. Use the method <tt>YCurrent.nextCurrent()</tt> to iterate on next current sensors.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to the first current sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Current']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'current&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a lineat interpolatation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'current&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Current']['get_advertisedValue']={syn:'Returns the current value of the current sensor (no more than 6 characters).',lib:'current&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the current sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the current sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Current']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'current&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Current']['get_currentValue']={syn:'Returns the current measured value.',lib:'current&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Current']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'current&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Current']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'current&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Current']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'current&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Current']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'current&rarr;get_currentDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Current']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'current&rarr;get_currentId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Current']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'current&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Current']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'current&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Current']['get_logicalName']={syn:'Returns the logical name of the current sensor.',lib:'current&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the current sensor.</p>',ret:'a string corresponding to the logical name of the current sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Current']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'current&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Current']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'current&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Current']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'current&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Current']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'current&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Current']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'current&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Current']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'current&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Current']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'current&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Current']['nextCurrent']={syn:'Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.',lib:'current&rarr;nextCurrent()',pro:'YCurrent * nextCurrent()',cmt:'<p>Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to a current sensor currently online, or a <tt>null</tt> pointer if there are no more current sensors to enumerate.'};
doc['Current']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'current&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Current']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'current&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_logicalName']={syn:'Changes the logical name of the current sensor.',lib:'current&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the current sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the current sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'current&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'current&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Current)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'CarbonDioxide function interface',inc:'#include &quot;yocto_carbondioxide.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['CarbonDioxide']['FindCarbonDioxide']={syn:'Retrieves a CO2 sensor for a given identifier.',lib:'YCarbonDioxide::FindCarbonDioxide()',pro:'YCarbonDioxide* FindCarbonDioxide(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a CO2 sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the CO2 sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCarbonDioxide.isOnline()</tt> to test if the CO2 sensor is indeed online at a given time. In case of ambiguity when looking for a CO2 sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the CO2 sensor'},ret:'a <tt>YCarbonDioxide</tt> object allowing you to drive the CO2 sensor.'};
doc['CarbonDioxide']['FirstCarbonDioxide']={syn:'Starts the enumeration of CO2 sensors currently accessible.',lib:'YCarbonDioxide::FirstCarbonDioxide()',pro:'YCarbonDioxide* FirstCarbonDioxide()',cmt:'<p>Starts the enumeration of CO2 sensors currently accessible. Use the method <tt>YCarbonDioxide.nextCarbonDioxide()</tt> to iterate on next CO2 sensors.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to the first CO2 sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'carbondioxide&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a lineat interpolatation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'carbondioxide&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Returns the current value of the CO2 sensor (no more than 6 characters).',lib:'carbondioxide&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the CO2 sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the CO2 sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'carbondioxide&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentValue']={syn:'Returns the current measured value.',lib:'carbondioxide&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'carbondioxide&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['CarbonDioxide']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'carbondioxide&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['CarbonDioxide']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'carbondioxide&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'carbondioxide&rarr;get_carbondioxideDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'carbondioxide&rarr;get_carbondioxideId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['CarbonDioxide']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'carbondioxide&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['CarbonDioxide']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'carbondioxide&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_logicalName']={syn:'Returns the logical name of the CO2 sensor.',lib:'carbondioxide&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the CO2 sensor.</p>',ret:'a string corresponding to the logical name of the CO2 sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'carbondioxide&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'carbondioxide&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['CarbonDioxide']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'carbondioxide&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['CarbonDioxide']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'carbondioxide&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['CarbonDioxide']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'carbondioxide&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['CarbonDioxide']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'carbondioxide&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['CarbonDioxide']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'carbondioxide&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['nextCarbonDioxide']={syn:'Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.',lib:'carbondioxide&rarr;nextCarbonDioxide()',pro:'YCarbonDioxide * nextCarbonDioxide()',cmt:'<p>Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to a CO2 sensor currently online, or a <tt>null</tt> pointer if there are no more CO2 sensors to enumerate.'};
doc['CarbonDioxide']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'carbondioxide&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['CarbonDioxide']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'carbondioxide&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_logicalName']={syn:'Changes the logical name of the CO2 sensor.',lib:'carbondioxide&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the CO2 sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the CO2 sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'carbondioxide&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'carbondioxide&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: VSource)
doc['VSource']={'':{syn:'Voltage source function interface',inc:'#include &quot;yocto_vsource.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you to control the module voltage output. You affect absolute output values or make transitions</p>'}};
doc['VSource']['FindVSource']={syn:'Retrieves a voltage source for a given identifier.',lib:'YVSource::FindVSource()',pro:'YVSource* FindVSource(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a voltage source for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the voltage source is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVSource.isOnline()</tt> to test if the voltage source is indeed online at a given time. In case of ambiguity when looking for a voltage source by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the voltage source'},ret:'a <tt>YVSource</tt> object allowing you to drive the voltage source.'};
doc['VSource']['FirstVSource']={syn:'Starts the enumeration of voltage sources currently accessible.',lib:'YVSource::FirstVSource()',pro:'YVSource* FirstVSource()',cmt:'<p>Starts the enumeration of voltage sources currently accessible. Use the method <tt>YVSource.nextVSource()</tt> to iterate on next voltage sources.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to the first voltage source currently online, or a <tt>null</tt> pointer if there are none.'};
doc['VSource']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'vsource&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['VSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'vsource&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VSource']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'vsource&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['VSource']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'vsource&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['VSource']['get_extPowerFailure']={syn:'Returns true if external power supply voltage is too low.',lib:'vsource&rarr;get_extPowerFailure()',pro:'Y_EXTPOWERFAILURE_enum get_extPowerFailure()',cmt:'<p>Returns true if external power supply voltage is too low.</p>',ret:'either <tt>Y_EXTPOWERFAILURE_FALSE</tt> or <tt>Y_EXTPOWERFAILURE_TRUE</tt>, according to true if external power supply voltage is too low',ext:'On failure, throws an exception or returns <tt>Y_EXTPOWERFAILURE_INVALID</tt>.'};
doc['VSource']['get_failure']={syn:'Returns true if the module is in failure mode.',lib:'vsource&rarr;get_failure()',pro:'Y_FAILURE_enum get_failure()',cmt:'<p>Returns true if the module is in failure mode. More information can be obtained by testing get_overheat, get_overcurrent etc... When a error condition is met, the output voltage is set to z\xE9ro and cannot be changed until the reset() function is called.</p>',ret:'either <tt>Y_FAILURE_FALSE</tt> or <tt>Y_FAILURE_TRUE</tt>, according to true if the module is in failure mode',ext:'On failure, throws an exception or returns <tt>Y_FAILURE_INVALID</tt>.'};
doc['VSource']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'vsource&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['VSource']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'vsource&rarr;get_vsourceDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['VSource']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'vsource&rarr;get_vsourceId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['VSource']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'vsource&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['VSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'vsource&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VSource']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'vsource&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['VSource']['get_overCurrent']={syn:'Returns true if the appliance connected to the device is too greedy .',lib:'vsource&rarr;get_overCurrent()',pro:'Y_OVERCURRENT_enum get_overCurrent()',cmt:'<p>Returns true if the appliance connected to the device is too greedy .</p>',ret:'either <tt>Y_OVERCURRENT_FALSE</tt> or <tt>Y_OVERCURRENT_TRUE</tt>, according to true if the appliance connected to the device is too greedy',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['VSource']['get_overHeat']={syn:'Returns TRUE if the module is overheating.',lib:'vsource&rarr;get_overHeat()',pro:'Y_OVERHEAT_enum get_overHeat()',cmt:'<p>Returns TRUE if the module is overheating.</p>',ret:'either <tt>Y_OVERHEAT_FALSE</tt> or <tt>Y_OVERHEAT_TRUE</tt>, according to TRUE if the module is overheating',ext:'On failure, throws an exception or returns <tt>Y_OVERHEAT_INVALID</tt>.'};
doc['VSource']['get_overLoad']={syn:'Returns true if the device is not able to maintaint the requested voltage output .',lib:'vsource&rarr;get_overLoad()',pro:'Y_OVERLOAD_enum get_overLoad()',cmt:'<p>Returns true if the device is not able to maintaint the requested voltage output .</p>',ret:'either <tt>Y_OVERLOAD_FALSE</tt> or <tt>Y_OVERLOAD_TRUE</tt>, according to true if the device is not able to maintaint the requested voltage output',ext:'On failure, throws an exception or returns <tt>Y_OVERLOAD_INVALID</tt>.'};
doc['VSource']['get_regulationFailure']={syn:'Returns true if the voltage output is too high regarding the requested voltage .',lib:'vsource&rarr;get_regulationFailure()',pro:'Y_REGULATIONFAILURE_enum get_regulationFailure()',cmt:'<p>Returns true if the voltage output is too high regarding the requested voltage .</p>',ret:'either <tt>Y_REGULATIONFAILURE_FALSE</tt> or <tt>Y_REGULATIONFAILURE_TRUE</tt>, according to true if the voltage output is too high regarding the requested voltage',ext:'On failure, throws an exception or returns <tt>Y_REGULATIONFAILURE_INVALID</tt>.'};
doc['VSource']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'vsource&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['VSource']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'vsource&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['VSource']['get_voltage']={syn:'Returns the voltage output command (mV) ',lib:'vsource&rarr;get_voltage()',pro:'int get_voltage()',cmt:'<p>Returns the voltage output command (mV)</p>',ret:'an integer corresponding to the voltage output command (mV)',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['VSource']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'vsource&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['VSource']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'vsource&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['VSource']['nextVSource']={syn:'Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.',lib:'vsource&rarr;nextVSource()',pro:'YVSource * nextVSource()',cmt:'<p>Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to a voltage source currently online, or a <tt>null</tt> pointer if there are no more voltage sources to enumerate.'};
doc['VSource']['pulse']={syn:'Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.',lib:'vsource&rarr;pulse()',pro:'int pulse(int <span id=pn>voltage</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.</p>',par:{voltage:'pulse voltage, in millivolts',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'vsource&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['VSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'vsource&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage source. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage source'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'vsource&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['VSource']['set_voltage']={syn:'Tunes the device output voltage (milliVolts).',lib:'vsource&rarr;set_voltage()',pro:'int set_voltage(int <span id=pn>newval</span>)',cmt:'<p>Tunes the device output voltage (milliVolts).</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['voltageMove']={syn:'Performs a smooth move at constant speed toward a given value.',lib:'vsource&rarr;voltageMove()',pro:'int voltageMove(int <span id=pn>target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given value.</p>',par:{target:'new output value at end of transition, in milliVolts.',ms_duration:'transition duration, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: VSource)
//--- (generated code: Network)
doc['Network']={'':{syn:'Network function interface',inc:'#include &quot;yocto_network.h&quot;',cmt:'<p>YNetwork objects provide access to TCP/IP parameters of Yoctopuce modules that include a built-in network interface.</p>'}};
doc['Network']['FindNetwork']={syn:'Retrieves a network interface for a given identifier.',lib:'YNetwork::FindNetwork()',pro:'YNetwork* FindNetwork(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a network interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the network interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YNetwork.isOnline()</tt> to test if the network interface is indeed online at a given time. In case of ambiguity when looking for a network interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the network interface'},ret:'a <tt>YNetwork</tt> object allowing you to drive the network interface.'};
doc['Network']['FirstNetwork']={syn:'Starts the enumeration of network interfaces currently accessible.',lib:'YNetwork::FirstNetwork()',pro:'YNetwork* FirstNetwork()',cmt:'<p>Starts the enumeration of network interfaces currently accessible. Use the method <tt>YNetwork.nextNetwork()</tt> to iterate on next network interfaces.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to the first network interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Network']['callbackLogin']={syn:'Connects to the notification callback and saves the credentials required to log in to it.',lib:'network&rarr;callbackLogin()',pro:'int callbackLogin(string <span id=pn>username</span>, string <span id=pn>password</span>)',cmt:'<p>Connects to the notification callback and saves the credentials required to log in to it. The password will not be stored into the module, only a hashed copy of the credentials will be saved. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{username:'username required to log to the callback',password:'password required to log to the callback'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'network&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Network']['get_adminPassword']={syn:'Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.',lib:'network&rarr;get_adminPassword()',pro:'string get_adminPassword()',cmt:'<p>Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_ADMINPASSWORD_INVALID</tt>.'};
doc['Network']['get_advertisedValue']={syn:'Returns the current value of the network interface (no more than 6 characters).',lib:'network&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the network interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the network interface (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Network']['get_callbackCredentials']={syn:'Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.',lib:'network&rarr;get_callbackCredentials()',pro:'string get_callbackCredentials()',cmt:'<p>Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.</p>',ret:'a string corresponding to a hashed version of the notification callback credentials if set, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKCREDENTIALS_INVALID</tt>.'};
doc['Network']['get_callbackEncoding']={syn:'Returns the encoding standard to use for representing notification values.',lib:'network&rarr;get_callbackEncoding()',pro:'Y_CALLBACKENCODING_enum get_callbackEncoding()',cmt:'<p>Returns the encoding standard to use for representing notification values.</p>',ret:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> and <tt>Y_CALLBACKENCODING_YOCTO_API</tt> corresponding to the encoding standard to use for representing notification values',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKENCODING_INVALID</tt>.'};
doc['Network']['get_callbackMaxDelay']={syn:'Returns the maximum wait time between two callback notifications, in seconds.',lib:'network&rarr;get_callbackMaxDelay()',pro:'unsigned get_callbackMaxDelay()',cmt:'<p>Returns the maximum wait time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the maximum wait time between two callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMAXDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMethod']={syn:'Returns the HTTP Method used to notify callbacks for significant state changes.',lib:'network&rarr;get_callbackMethod()',pro:'Y_CALLBACKMETHOD_enum get_callbackMethod()',cmt:'<p>Returns the HTTP Method used to notify callbacks for significant state changes.</p>',ret:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP Method used to notify callbacks for significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMETHOD_INVALID</tt>.'};
doc['Network']['get_callbackMinDelay']={syn:'Returns the minimum wait time between two callback notifications, in seconds.',lib:'network&rarr;get_callbackMinDelay()',pro:'unsigned get_callbackMinDelay()',cmt:'<p>Returns the minimum wait time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the minimum wait time between two callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMINDELAY_INVALID</tt>.'};
doc['Network']['get_callbackUrl']={syn:'Returns the callback URL to notify of significant state changes.',lib:'network&rarr;get_callbackUrl()',pro:'string get_callbackUrl()',cmt:'<p>Returns the callback URL to notify of significant state changes.</p>',ret:'a string corresponding to the callback URL to notify of significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKURL_INVALID</tt>.'};
doc['Network']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'network&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Network']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'network&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Network']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'network&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Network']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'network&rarr;get_networkDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Network']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'network&rarr;get_networkId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Network']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'network&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Network']['get_ipAddress']={syn:'Returns the IP address currently in use by the device.',lib:'network&rarr;get_ipAddress()',pro:'string get_ipAddress()',cmt:'<p>Returns the IP address currently in use by the device. The adress may have been configured statically, or provided by a DHCP server.</p>',ret:'a string corresponding to the IP address currently in use by the device',ext:'On failure, throws an exception or returns <tt>Y_IPADDRESS_INVALID</tt>.'};
doc['Network']['get_logicalName']={syn:'Returns the logical name of the network interface, corresponding to the network name of the module.',lib:'network&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the network interface, corresponding to the network name of the module.</p>',ret:'a string corresponding to the logical name of the network interface, corresponding to the network name of the module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Network']['get_macAddress']={syn:'Returns the MAC address of the network interface.',lib:'network&rarr;get_macAddress()',pro:'string get_macAddress()',cmt:'<p>Returns the MAC address of the network interface. The MAC address is also available on a sticker on the module, in both numeric and barcode forms.</p>',ret:'a string corresponding to the MAC address of the network interface',ext:'On failure, throws an exception or returns <tt>Y_MACADDRESS_INVALID</tt>.'};
doc['Network']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'network&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Network']['get_primaryDNS']={syn:'Returns the IP address of the primary name server to be used by the module.',lib:'network&rarr;get_primaryDNS()',pro:'string get_primaryDNS()',cmt:'<p>Returns the IP address of the primary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the primary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_PRIMARYDNS_INVALID</tt>.'};
doc['Network']['get_readiness']={syn:'Returns the current established working mode of the network interface.',lib:'network&rarr;get_readiness()',pro:'Y_READINESS_enum get_readiness()',cmt:'<p>Returns the current established working mode of the network interface. Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal on the network cable, or the selected wireless access point cannot be detected. Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected, For a wireless network, this shows that the requested SSID is present. Level 2 (LINK_2) is reached when the hardware connection is established. For a wired network connection, level 2 means that the cable is attached on both ends. For a connection to a wireless access point, it shows that the security parameters are properly configured. For an ad-hoc wireless connection, it means that there is at least one other device connected on the ad-hoc network. Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP. Level 4 (DNS_4) is reached when the DNS server is reachable on the network. Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading current time from an NTP server.</p>',ret:'a value among <tt>Y_READINESS_DOWN</tt>, <tt>Y_READINESS_EXISTS</tt>, <tt>Y_READINESS_LINKED</tt>, <tt>Y_READINESS_LAN_OK</tt> and <tt>Y_READINESS_WWW_OK</tt> corresponding to the current established working mode of the network interface',ext:'On failure, throws an exception or returns <tt>Y_READINESS_INVALID</tt>.'};
doc['Network']['get_router']={syn:'Returns the IP address of the router on the device subnet (default gateway).',lib:'network&rarr;get_router()',pro:'string get_router()',cmt:'<p>Returns the IP address of the router on the device subnet (default gateway).</p>',ret:'a string corresponding to the IP address of the router on the device subnet (default gateway)',ext:'On failure, throws an exception or returns <tt>Y_ROUTER_INVALID</tt>.'};
doc['Network']['get_secondaryDNS']={syn:'Returns the IP address of the secondary name server to be used by the module.',lib:'network&rarr;get_secondaryDNS()',pro:'string get_secondaryDNS()',cmt:'<p>Returns the IP address of the secondary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the secondary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_SECONDARYDNS_INVALID</tt>.'};
doc['Network']['get_subnetMask']={syn:'Returns the subnet mask currently used by the device.',lib:'network&rarr;get_subnetMask()',pro:'string get_subnetMask()',cmt:'<p>Returns the subnet mask currently used by the device.</p>',ret:'a string corresponding to the subnet mask currently used by the device',ext:'On failure, throws an exception or returns <tt>Y_SUBNETMASK_INVALID</tt>.'};
doc['Network']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'network&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Network']['get_userPassword']={syn:'Returns a hash string if a password has been set for user \x22user\x22, or an empty string otherwise.',lib:'network&rarr;get_userPassword()',pro:'string get_userPassword()',cmt:'<p>Returns a hash string if a password has been set for user \x22user\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22user\x22, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_USERPASSWORD_INVALID</tt>.'};
doc['Network']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'network&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Network']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'network&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Network']['nextNetwork']={syn:'Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.',lib:'network&rarr;nextNetwork()',pro:'YNetwork * nextNetwork()',cmt:'<p>Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to a network interface currently online, or a <tt>null</tt> pointer if there are no more network interfaces to enumerate.'};
doc['Network']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'network&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Network']['set_adminPassword']={syn:'Changes the password for the \x22admin\x22 user.',lib:'network&rarr;set_adminPassword()',pro:'int set_adminPassword(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22admin\x22 user. This password becomes instantly required to perform any change of the module state. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22admin\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackCredentials']={syn:'Changes the credentials required to connect to the callback address.',lib:'network&rarr;set_callbackCredentials()',pro:'int set_callbackCredentials(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the credentials required to connect to the callback address. The credentials must be provided as returned by function <tt>get_callbackCredentials</tt>, in the form <tt>username:hash</tt>. The method used to compute the hash varies according to the the authentication scheme implemented by the callback, For Basic authentication, the hash is the MD5 of the string <tt>username:password</tt>. For Digest authentication, the hash is the MD5 of the string <tt>username:realm:password</tt>. For a simpler way to configure callback credentials, use function <tt>callbackLogin</tt> instead. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the credentials required to connect to the callback address'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackEncoding']={syn:'Changes the encoding standard to use for representing notification values.',lib:'network&rarr;set_callbackEncoding()',pro:'int set_callbackEncoding(Y_CALLBACKENCODING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the encoding standard to use for representing notification values.</p>',par:{newval:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> and <tt>Y_CALLBACKENCODING_YOCTO_API</tt> corresponding to the encoding standard to use for representing notification values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMaxDelay']={syn:'Changes the maximum wait time between two callback notifications, in seconds.',lib:'network&rarr;set_callbackMaxDelay()',pro:'int set_callbackMaxDelay(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the maximum wait time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the maximum wait time between two callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMethod']={syn:'Changes the HTTP Method used to notify callbacks for significant state changes.',lib:'network&rarr;set_callbackMethod()',pro:'int set_callbackMethod(Y_CALLBACKMETHOD_enum <span id=pn>newval</span>)',cmt:'<p>Changes the HTTP Method used to notify callbacks for significant state changes.</p>',par:{newval:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP Method used to notify callbacks for significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMinDelay']={syn:'Changes the minimum wait time between two callback notifications, in seconds.',lib:'network&rarr;set_callbackMinDelay()',pro:'int set_callbackMinDelay(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the minimum wait time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the minimum wait time between two callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackUrl']={syn:'Changes the callback URL to notify of significant state changes.',lib:'network&rarr;set_callbackUrl()',pro:'int set_callbackUrl(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the callback URL to notify of significant state changes. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the callback URL to notify of significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_logicalName']={syn:'Changes the logical name of the network interface, corresponding to the network name of the module.',lib:'network&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the network interface, corresponding to the network name of the module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the network interface, corresponding to the network name of the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_primaryDNS']={syn:'Changes the IP address of the primary name server to be used by the module.',lib:'network&rarr;set_primaryDNS()',pro:'int set_primaryDNS(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the primary name server to be used by the module. When using DHCP, if a value is specified, it will override the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the primary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_secondaryDNS']={syn:'Changes the IP address of the secondarz name server to be used by the module.',lib:'network&rarr;set_secondaryDNS()',pro:'int set_secondaryDNS(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the secondarz name server to be used by the module. When using DHCP, if a value is specified, it will override the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the secondarz name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'network&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Network']['set_userPassword']={syn:'Changes the password for the \x22user\x22 user.',lib:'network&rarr;set_userPassword()',pro:'int set_userPassword(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22user\x22 user. This password becomes instantly required to perform any use of the module. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22user\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useDHCP']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'network&rarr;useDHCP()',pro:'int useDHCP(string <span id=pn>fallbackIpAddr</span>,&nbsp;int <span id=pn>fallbackSubnetMaskLen</span>,&nbsp;string <span id=pn>fallbackRouter</span>)',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module will use the IP parameters specified to this function. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{fallbackIpAddr:'fallback IP address, to be used when no DHCP reply is received',fallbackSubnetMaskLen:'fallback subnet mask length when no DHCP reply is received, as an integer (eg. 24 means 255.255.255.0)',fallbackRouter:'fallback router IP address, to be used when no DHCP reply is received'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useStaticIP']={syn:'Changes the configuration of the network interface to use a static IP address.',lib:'network&rarr;useStaticIP()',pro:'int useStaticIP(string <span id=pn>ipAddress</span>,&nbsp;int <span id=pn>subnetMaskLen</span>,&nbsp;string <span id=pn>router</span>)',cmt:'<p>Changes the configuration of the network interface to use a static IP address. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ipAddress:'device IP address',subnetMaskLen:'subnet mask length, as an integer (eg. 24 means 255.255.255.0)',router:'router IP address (default gateway)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Network)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Wireless function interface',inc:'#include &quot;yocto_wireless.h&quot;'}};
doc['Wireless']['FindWireless']={syn:'Retrieves a wireless lan interface for a given identifier.',lib:'YWireless::FindWireless()',pro:'YWireless* FindWireless(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a wireless lan interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the wireless lan interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWireless.isOnline()</tt> to test if the wireless lan interface is indeed online at a given time. In case of ambiguity when looking for a wireless lan interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the wireless lan interface'},ret:'a <tt>YWireless</tt> object allowing you to drive the wireless lan interface.'};
doc['Wireless']['FirstWireless']={syn:'Starts the enumeration of wireless lan interfaces currently accessible.',lib:'YWireless::FirstWireless()',pro:'YWireless* FirstWireless()',cmt:'<p>Starts the enumeration of wireless lan interfaces currently accessible. Use the method <tt>YWireless.nextWireless()</tt> to iterate on next wireless lan interfaces.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to the first wireless lan interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Wireless']['adhocNetwork']={syn:'Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point.',lib:'wireless&rarr;adhocNetwork()',pro:'int adhocNetwork(string <span id=pn>ssid</span>, string <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point. If a security key is specified, the network will be protected by WEP128, since WPA is not standardized for ad-hoc networks. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wireless&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Wireless']['get_advertisedValue']={syn:'Returns the current value of the wireless lan interface (no more than 6 characters).',lib:'wireless&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the wireless lan interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wireless lan interface (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Wireless']['get_channel']={syn:'Returns the 802.',lib:'wireless&rarr;get_channel()',pro:'unsigned get_channel()',cmt:'<p>Returns the 802.11 channel currently used, or 0 when the selected network has not been found.</p>',ret:'an integer corresponding to the 802',ext:'On failure, throws an exception or returns <tt>Y_CHANNEL_INVALID</tt>.'};
doc['Wireless']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'wireless&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Wireless']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'wireless&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Wireless']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wireless&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Wireless']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wireless&rarr;get_wirelessDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Wireless']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'wireless&rarr;get_wirelessId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Wireless']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'wireless&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Wireless']['get_linkQuality']={syn:'Returns the link quality, expressed in per cents.',lib:'wireless&rarr;get_linkQuality()',pro:'int get_linkQuality()',cmt:'<p>Returns the link quality, expressed in per cents.</p>',ret:'an integer corresponding to the link quality, expressed in per cents',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Wireless']['get_logicalName']={syn:'Returns the logical name of the wireless lan interface.',lib:'wireless&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the wireless lan interface.</p>',ret:'a string corresponding to the logical name of the wireless lan interface',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Wireless']['get_message']={syn:'Returns the last status message from the wireless interface.',lib:'wireless&rarr;get_message()',pro:'string get_message()',cmt:'<p>Returns the last status message from the wireless interface.</p>',ret:'a string corresponding to the last status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Wireless']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wireless&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Wireless']['get_security']={syn:'Returns the security algorithm used by the selected wireless network.',lib:'wireless&rarr;get_security()',pro:'Y_SECURITY_enum get_security()',cmt:'<p>Returns the security algorithm used by the selected wireless network.</p>',ret:'a value among <tt>Y_SECURITY_UNKNOWN</tt>, <tt>Y_SECURITY_OPEN</tt>, <tt>Y_SECURITY_WEP</tt>, <tt>Y_SECURITY_WPA</tt> and <tt>Y_SECURITY_WPA2</tt> corresponding to the security algorithm used by the selected wireless network',ext:'On failure, throws an exception or returns <tt>Y_SECURITY_INVALID</tt>.'};
doc['Wireless']['get_ssid']={syn:'Returns the wireless network name (SSID).',lib:'wireless&rarr;get_ssid()',pro:'string get_ssid()',cmt:'<p>Returns the wireless network name (SSID).</p>',ret:'a string corresponding to the wireless network name (SSID)',ext:'On failure, throws an exception or returns <tt>Y_SSID_INVALID</tt>.'};
doc['Wireless']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wireless&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Wireless']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'wireless&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Wireless']['joinNetwork']={syn:'Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).',lib:'wireless&rarr;joinNetwork()',pro:'int joinNetwork(string <span id=pn>ssid</span>, string <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode). Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'wireless&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['nextWireless']={syn:'Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>.',lib:'wireless&rarr;nextWireless()',pro:'YWireless * nextWireless()',cmt:'<p>Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to a wireless lan interface currently online, or a <tt>null</tt> pointer if there are no more wireless lan interfaces to enumerate.'};
doc['Wireless']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wireless&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Wireless']['set_logicalName']={syn:'Changes the logical name of the wireless lan interface.',lib:'wireless&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wireless lan interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wireless lan interface'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wireless&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Wireless)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Voc function interface',inc:'#include &quot;yocto_voc.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Voc']['FindVoc']={syn:'Retrieves a Volatile Organic Compound sensor for a given identifier.',lib:'YVoc::FindVoc()',pro:'YVoc* FindVoc(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a Volatile Organic Compound sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the Volatile Organic Compound sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoc.isOnline()</tt> to test if the Volatile Organic Compound sensor is indeed online at a given time. In case of ambiguity when looking for a Volatile Organic Compound sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the Volatile Organic Compound sensor'},ret:'a <tt>YVoc</tt> object allowing you to drive the Volatile Organic Compound sensor.'};
doc['Voc']['FirstVoc']={syn:'Starts the enumeration of Volatile Organic Compound sensors currently accessible.',lib:'YVoc::FirstVoc()',pro:'YVoc* FirstVoc()',cmt:'<p>Starts the enumeration of Volatile Organic Compound sensors currently accessible. Use the method <tt>YVoc.nextVoc()</tt> to iterate on next Volatile Organic Compound sensors.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to the first Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voc']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voc&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a lineat interpolatation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voc&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voc']['get_advertisedValue']={syn:'Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).',lib:'voc&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Volatile Organic Compound sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voc']['get_currentRawValue']={syn:'Returns the unrounded and uncalibrated raw value returned by the sensor.',lib:'voc&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the unrounded and uncalibrated raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the unrounded and uncalibrated raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voc']['get_currentValue']={syn:'Returns the current measured value.',lib:'voc&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voc']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'voc&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Voc']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'voc&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Voc']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voc&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voc']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voc&rarr;get_vocDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voc']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'voc&rarr;get_vocId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voc']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'voc&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voc']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'voc&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voc']['get_logicalName']={syn:'Returns the logical name of the Volatile Organic Compound sensor.',lib:'voc&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Volatile Organic Compound sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voc']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'voc&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voc']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voc&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voc']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voc&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voc']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'voc&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voc']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voc&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voc']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'voc&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Voc']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'voc&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Voc']['nextVoc']={syn:'Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.',lib:'voc&rarr;nextVoc()',pro:'YVoc * nextVoc()',cmt:'<p>Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to a Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are no more Volatile Organic Compound sensors to enumerate.'};
doc['Voc']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voc&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voc']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voc&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_logicalName']={syn:'Changes the logical name of the Volatile Organic Compound sensor.',lib:'voc&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Volatile Organic Compound sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Volatile Organic Compound sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voc&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voc&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Voc)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Watchdog function interface',inc:'#include &quot;yocto_watchdog.h&quot;',cmt:'<p>The watchog function works like a relay and can cause a brief power cut to an appliance after a preset delay to force this appliance to reset. The Watchdog must be called from time to time to reset the timer and prevent the appliance reset. The watchdog can be driven direcly with <i>pulse</i> and <i>delayedpulse</i> methods to switch off an appliance for a given duration.</p>'}};
doc['Watchdog']['FindWatchdog']={syn:'Retrieves a watchdog for a given identifier.',lib:'YWatchdog::FindWatchdog()',pro:'YWatchdog* FindWatchdog(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a watchdog for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the watchdog is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWatchdog.isOnline()</tt> to test if the watchdog is indeed online at a given time. In case of ambiguity when looking for a watchdog by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the watchdog'},ret:'a <tt>YWatchdog</tt> object allowing you to drive the watchdog.'};
doc['Watchdog']['FirstWatchdog']={syn:'Starts the enumeration of watchdog currently accessible.',lib:'YWatchdog::FirstWatchdog()',pro:'YWatchdog* FirstWatchdog()',cmt:'<p>Starts the enumeration of watchdog currently accessible. Use the method <tt>YWatchdog.nextWatchdog()</tt> to iterate on next watchdog.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to the first watchdog currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Watchdog']['delayedPulse']={syn:'Schedules a pulse.',lib:'watchdog&rarr;delayedPulse()',pro:'int delayedPulse(int <span id=pn>ms_delay</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'watchdog&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Watchdog']['get_advertisedValue']={syn:'Returns the current value of the watchdog (no more than 6 characters).',lib:'watchdog&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the watchdog (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the watchdog (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Watchdog']['get_autoStart']={syn:'Returns the watchdog runing state at module power up.',lib:'watchdog&rarr;get_autoStart()',pro:'Y_AUTOSTART_enum get_autoStart()',cmt:'<p>Returns the watchdog runing state at module power up.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog runing state at module power up',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['Watchdog']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'watchdog&rarr;get_countdown()',pro:'unsigned get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Watchdog']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'watchdog&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Watchdog']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'watchdog&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Watchdog']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'watchdog&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Watchdog']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'watchdog&rarr;get_watchdogDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Watchdog']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'watchdog&rarr;get_watchdogId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Watchdog']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'watchdog&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Watchdog']['get_logicalName']={syn:'Returns the logical name of the watchdog.',lib:'watchdog&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the watchdog.</p>',ret:'a string corresponding to the logical name of the watchdog',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Watchdog']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'watchdog&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Watchdog']['get_output']={syn:'Returns the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog&rarr;get_output()',pro:'Y_OUTPUT_enum get_output()',cmt:'<p>Returns the output state of the watchdog, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Watchdog']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation.',lib:'watchdog&rarr;get_pulseTimer()',pro:'unsigned get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Watchdog']['get_running']={syn:'Returns the watchdog running state.',lib:'watchdog&rarr;get_running()',pro:'Y_RUNNING_enum get_running()',cmt:'<p>Returns the watchdog running state.</p>',ret:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the watchdog running state',ext:'On failure, throws an exception or returns <tt>Y_RUNNING_INVALID</tt>.'};
doc['Watchdog']['get_state']={syn:'Returns the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog&rarr;get_state()',pro:'Y_STATE_enum get_state()',cmt:'<p>Returns the state of the watchdog (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Watchdog']['get_triggerDelay']={syn:'Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.',lib:'watchdog&rarr;get_triggerDelay()',pro:'unsigned get_triggerDelay()',cmt:'<p>Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDELAY_INVALID</tt>.'};
doc['Watchdog']['get_triggerDuration']={syn:'Returns the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog&rarr;get_triggerDuration()',pro:'unsigned get_triggerDuration()',cmt:'<p>Returns the duration of resets caused by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDURATION_INVALID</tt>.'};
doc['Watchdog']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'watchdog&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Watchdog']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'watchdog&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Watchdog']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'watchdog&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['nextWatchdog']={syn:'Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.',lib:'watchdog&rarr;nextWatchdog()',pro:'YWatchdog * nextWatchdog()',cmt:'<p>Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to a watchdog currently online, or a <tt>null</tt> pointer if there are no more watchdog to enumerate.'};
doc['Watchdog']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'watchdog&rarr;pulse()',pro:'int pulse(int <span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'watchdog&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Watchdog']['resetWatchdog']={syn:'Resets the watchdog.',lib:'watchdog&rarr;resetWatchdog()',pro:'int resetWatchdog()',cmt:'<p>Resets the watchdog. When the watchdog is running, this function must be called on a regular basis to prevent the watchog to trigger</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_autoStart']={syn:'Changes the watchdog runningsttae at module power up.',lib:'watchdog&rarr;set_autoStart()',pro:'int set_autoStart(Y_AUTOSTART_enum <span id=pn>newval</span>)',cmt:'<p>Changes the watchdog runningsttae at module power up. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog runningsttae at module power up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_logicalName']={syn:'Changes the logical name of the watchdog.',lib:'watchdog&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the watchdog. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the watchdog'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_output']={syn:'Changes the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog&rarr;set_output()',pro:'int set_output(Y_OUTPUT_enum <span id=pn>newval</span>)',cmt:'<p>Changes the output state of the watchdog, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_running']={syn:'Changes the running state of the watchdog.',lib:'watchdog&rarr;set_running()',pro:'int set_running(Y_RUNNING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the running state of the watchdog.</p>',par:{newval:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the running state of the watchdog'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_state']={syn:'Changes the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog&rarr;set_state()',pro:'int set_state(Y_STATE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the watchdog (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDelay']={syn:'Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.',lib:'watchdog&rarr;set_triggerDelay()',pro:'int set_triggerDelay(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the waiting delay before a reset is triggered by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDuration']={syn:'Changes the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog&rarr;set_triggerDuration()',pro:'int set_triggerDuration(unsigned <span id=pn>newval</span>)',cmt:'<p>Changes the duration of resets caused by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'watchdog&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Watchdog)
//--- (generated code: Power)
doc['Power']={'':{syn:'Power function interface',inc:'#include &quot;yocto_power.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Power']['FindPower']={syn:'Retrieves a electrical power sensor for a given identifier.',lib:'YPower::FindPower()',pro:'YPower* FindPower(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a electrical power sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the electrical power sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPower.isOnline()</tt> to test if the electrical power sensor is indeed online at a given time. In case of ambiguity when looking for a electrical power sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the electrical power sensor'},ret:'a <tt>YPower</tt> object allowing you to drive the electrical power sensor.'};
doc['Power']['FirstPower']={syn:'Starts the enumeration of electrical power sensors currently accessible.',lib:'YPower::FirstPower()',pro:'YPower* FirstPower()',cmt:'<p>Starts the enumeration of electrical power sensors currently accessible. Use the method <tt>YPower.nextPower()</tt> to iterate on next electrical power sensors.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to the first electrical power sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Power']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'power&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a lineat interpolatation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'power&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Power']['get_advertisedValue']={syn:'Returns the current value of the electrical power sensor (no more than 6 characters).',lib:'power&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the electrical power sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the electrical power sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Power']['get_cosPhi']={syn:'Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).',lib:'power&rarr;get_cosPhi()',pro:'double get_cosPhi()',cmt:'<p>Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).</p>',ret:'a floating point number corresponding to the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA)',ext:'On failure, throws an exception or returns <tt>Y_COSPHI_INVALID</tt>.'};
doc['Power']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'power&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Power']['get_currentValue']={syn:'Returns the current measured value.',lib:'power&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Power']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'power&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Power']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'power&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Power']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'power&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Power']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'power&rarr;get_powerDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Power']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'power&rarr;get_powerId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Power']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'power&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Power']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'power&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Power']['get_logicalName']={syn:'Returns the logical name of the electrical power sensor.',lib:'power&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the electrical power sensor.</p>',ret:'a string corresponding to the logical name of the electrical power sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Power']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'power&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Power']['get_meter']={syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.',lib:'power&rarr;get_meter()',pro:'double get_meter()',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time. Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time',ext:'On failure, throws an exception or returns <tt>Y_METER_INVALID</tt>.'};
doc['Power']['get_meterTimer']={syn:'Returns the elapsed time since last energy counter reset, in seconds.',lib:'power&rarr;get_meterTimer()',pro:'unsigned get_meterTimer()',cmt:'<p>Returns the elapsed time since last energy counter reset, in seconds.</p>',ret:'an integer corresponding to the elapsed time since last energy counter reset, in seconds',ext:'On failure, throws an exception or returns <tt>Y_METERTIMER_INVALID</tt>.'};
doc['Power']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'power&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Power']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'power&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Power']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'power&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Power']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'power&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Power']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'power&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Power']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'power&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Power']['nextPower']={syn:'Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.',lib:'power&rarr;nextPower()',pro:'YPower * nextPower()',cmt:'<p>Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to a electrical power sensor currently online, or a <tt>null</tt> pointer if there are no more electrical power sensors to enumerate.'};
doc['Power']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'power&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Power']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'power&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_logicalName']={syn:'Changes the logical name of the electrical power sensor.',lib:'power&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the electrical power sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the electrical power sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'power&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'power&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Power)
//--- (generated code: Display)
doc['Display']={'':{syn:'Display function interface',inc:'#include &quot;yocto_display.h&quot;',cmt:'<p>Yoctopuce display interface has been designed to easily show information and images. The device provides built-in multi-layer rendering. Layers can be drawn offline, individually, and freely moved on the display. It can also replay recorded sequences (animations).</p>'}};
doc['Display']['FindDisplay']={syn:'Retrieves a display for a given identifier.',lib:'YDisplay::FindDisplay()',pro:'YDisplay* FindDisplay(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the display is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDisplay.isOnline()</tt> to test if the display is indeed online at a given time. In case of ambiguity when looking for a display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the display'},ret:'a <tt>YDisplay</tt> object allowing you to drive the display.'};
doc['Display']['FirstDisplay']={syn:'Starts the enumeration of displays currently accessible.',lib:'YDisplay::FirstDisplay()',pro:'YDisplay* FirstDisplay()',cmt:'<p>Starts the enumeration of displays currently accessible. Use the method <tt>YDisplay.nextDisplay()</tt> to iterate on next displays.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to the first display currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Display']['copyLayerContent']={syn:'Copies the whole content of a layer to another layer.',lib:'display&rarr;copyLayerContent()',pro:'int copyLayerContent(int <span id=pn>srcLayerId</span>, int <span id=pn>dstLayerId</span>)',cmt:'<p>Copies the whole content of a layer to another layer. The color and transparency of all the pixels from the destination layer are set to match the source pixels. This method only affects the displayed content, but does not change any property of the layer object. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{srcLayerId:'the identifier of the source layer (a number in range 0..layerCount-1)',dstLayerId:'the identifier of the destination layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'display&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Display']['fade']={syn:'Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.',lib:'display&rarr;fade()',pro:'int fade(int <span id=pn>brightness</span>, int <span id=pn>duration</span>)',cmt:'<p>Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.</p>',par:{brightness:'the new screen brightness',duration:'duration of the brightness transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['get_advertisedValue']={syn:'Returns the current value of the display (no more than 6 characters).',lib:'display&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the display (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the display (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Display']['get_brightness']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'display&rarr;get_brightness()',pro:'int get_brightness()',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_BRIGHTNESS_INVALID</tt>.'};
doc['Display']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'display&rarr;get_displayHeight()',pro:'unsigned get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYHEIGHT_INVALID</tt>.'};
doc['Display']['get_displayLayer']={syn:'Returns a YDisplayLayer object that can be used to draw on the specified layer.',lib:'display&rarr;get_displayLayer()',pro:'YDisplayLayer* get_displayLayer(unsigned <span id=pn>layerId</span>)',cmt:'<p>Returns a YDisplayLayer object that can be used to draw on the specified layer. The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>',par:{layerId:'the identifier of the layer (a number in range 0..layerCount-1)'},ret:'an <tt>YDisplayLayer</tt> object',ext:'On failure, throws an exception or returns <tt>null</tt>.'};
doc['Display']['get_displayType']={syn:'Returns the display type: monochrome, gray levels or full color.',lib:'display&rarr;get_displayType()',pro:'Y_DISPLAYTYPE_enum get_displayType()',cmt:'<p>Returns the display type: monochrome, gray levels or full color.</p>',ret:'a value among <tt>Y_DISPLAYTYPE_MONO</tt>, <tt>Y_DISPLAYTYPE_GRAY</tt> and <tt>Y_DISPLAYTYPE_RGB</tt> corresponding to the display type: monochrome, gray levels or full color',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYTYPE_INVALID</tt>.'};
doc['Display']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'display&rarr;get_displayWidth()',pro:'unsigned get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYWIDTH_INVALID</tt>.'};
doc['Display']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'display&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Display']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'display&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Display']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'display&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Display']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'display&rarr;get_displayDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Display']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'display&rarr;get_displayId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Display']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'display&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Display']['get_layerCount']={syn:'Returns the number of available layers to draw on.',lib:'display&rarr;get_layerCount()',pro:'unsigned get_layerCount()',cmt:'<p>Returns the number of available layers to draw on.</p>',ret:'an integer corresponding to the number of available layers to draw on',ext:'On failure, throws an exception or returns <tt>Y_LAYERCOUNT_INVALID</tt>.'};
doc['Display']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'display&rarr;get_layerHeight()',pro:'unsigned get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERHEIGHT_INVALID</tt>.'};
doc['Display']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'display&rarr;get_layerWidth()',pro:'unsigned get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERWIDTH_INVALID</tt>.'};
doc['Display']['get_logicalName']={syn:'Returns the logical name of the display.',lib:'display&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the display.</p>',ret:'a string corresponding to the logical name of the display',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Display']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'display&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Display']['get_orientation']={syn:'Returns the currently selected display orientation.',lib:'display&rarr;get_orientation()',pro:'Y_ORIENTATION_enum get_orientation()',cmt:'<p>Returns the currently selected display orientation.</p>',ret:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the currently selected display orientation',ext:'On failure, throws an exception or returns <tt>Y_ORIENTATION_INVALID</tt>.'};
doc['Display']['get_powerState']={syn:'Returns the power state of the display.',lib:'display&rarr;get_powerState()',pro:'Y_POWERSTATE_enum get_powerState()',cmt:'<p>Returns the power state of the display.</p>',ret:'either <tt>Y_POWERSTATE_OFF</tt> or <tt>Y_POWERSTATE_ON</tt>, according to the power state of the display',ext:'On failure, throws an exception or returns <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['Display']['get_startupSeq']={syn:'Returns the name of the sequence to play when the displayed is powered on.',lib:'display&rarr;get_startupSeq()',pro:'string get_startupSeq()',cmt:'<p>Returns the name of the sequence to play when the displayed is powered on.</p>',ret:'a string corresponding to the name of the sequence to play when the displayed is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPSEQ_INVALID</tt>.'};
doc['Display']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'display&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Display']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'display&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Display']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'display&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Display']['newSequence']={syn:'Starts to record all display commands into a sequence, for later replay.',lib:'display&rarr;newSequence()',pro:'int newSequence()',cmt:'<p>Starts to record all display commands into a sequence, for later replay. The name used to store the sequence is specified when calling <tt>saveSequence()</tt>, once the recording is complete.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['nextDisplay']={syn:'Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.',lib:'display&rarr;nextDisplay()',pro:'YDisplay * nextDisplay()',cmt:'<p>Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to a display currently online, or a <tt>null</tt> pointer if there are no more displays to enumerate.'};
doc['Display']['pauseSequence']={syn:'Waits for a specified delay (in milliseconds) before playing next commands in current sequence.',lib:'display&rarr;pauseSequence()',pro:'int pauseSequence(int <span id=pn>delay_ms</span>)',cmt:'<p>Waits for a specified delay (in milliseconds) before playing next commands in current sequence. This method can be used while recording a display sequence, to insert a timed wait in the sequence (without any immediate effect). It can also be used dynamically while playing a pre-recorded sequence, to suspend or resume the execution of the sequence. To cancel a delay, call the same method with a zero delay.</p>',par:{delay_ms:'the duration to wait, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['playSequence']={syn:'Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.',lib:'display&rarr;playSequence()',pro:'int playSequence(string <span id=pn>sequenceName</span>)',cmt:'<p>Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'display&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Display']['resetAll']={syn:'Clears the display screen and resets all display layers to their default state.',lib:'display&rarr;resetAll()',pro:'int resetAll()',cmt:'<p>Clears the display screen and resets all display layers to their default state.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['saveSequence']={syn:'Stops recording display commands and saves the sequence into the specified file on the display internal memory.',lib:'display&rarr;saveSequence()',pro:'int saveSequence(string <span id=pn>sequenceName</span>)',cmt:'<p>Stops recording display commands and saves the sequence into the specified file on the display internal memory. The sequence can be later replayed using <tt>playSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_brightness']={syn:'Changes the brightness of the display.',lib:'display&rarr;set_brightness()',pro:'int set_brightness(int <span id=pn>newval</span>)',cmt:'<p>Changes the brightness of the display. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the brightness of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_logicalName']={syn:'Changes the logical name of the display.',lib:'display&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the display. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_orientation']={syn:'Changes the display orientation.',lib:'display&rarr;set_orientation()',pro:'int set_orientation(Y_ORIENTATION_enum <span id=pn>newval</span>)',cmt:'<p>Changes the display orientation. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the display orientation'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_powerState']={syn:'Changes the power state of the display.',lib:'display&rarr;set_powerState()',pro:'int set_powerState(Y_POWERSTATE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the power state of the display.</p>',par:{newval:'either <tt>Y_POWERSTATE_OFF</tt> or <tt>Y_POWERSTATE_ON</tt>, according to the power state of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_startupSeq']={syn:'Changes the name of the sequence to play when the displayed is powered on.',lib:'display&rarr;set_startupSeq()',pro:'int set_startupSeq(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the name of the sequence to play when the displayed is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the name of the sequence to play when the displayed is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'display&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Display']['stopSequence']={syn:'Stops immediately any ongoing sequence replay.',lib:'display&rarr;stopSequence()',pro:'int stopSequence()',cmt:'<p>Stops immediately any ongoing sequence replay. The display is left as is.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['swapLayerContent']={syn:'Swaps the whole content of two layers.',lib:'display&rarr;swapLayerContent()',pro:'int swapLayerContent(int <span id=pn>layerIdA</span>, int <span id=pn>layerIdB</span>)',cmt:'<p>Swaps the whole content of two layers. The color and transparency of all the pixels from the two layers are swapped. This method only affects the displayed content, but does not change any property of the layer objects. In particular, the visibility of each layer stays unchanged. When used between onae hidden layer and a visible layer, this method makes it possible to easily implement double-buffering. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{layerIdA:'the first layer (a number in range 0..layerCount-1)',layerIdB:'the second layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['upload']={syn:'Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name.',lib:'display&rarr;upload()',pro:'int upload(string <span id=pn>pathname</span>, string <span id=pn>content</span>)',cmt:'<p>Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Display)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'DisplayLayer object interface',inc:'#include &quot;yocto_display.h&quot;',cmt:'<p>A DisplayLayer is an image layer containing objects to display (bitmaps, text, etc.). The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>'}};
doc['DisplayLayer']['clear']={syn:'Erases the whole content of the layer (makes it fully transparent).',lib:'displaylayer&rarr;clear()',pro:'int clear()',cmt:'<p>Erases the whole content of the layer (makes it fully transparent). This method does not change any other attribute of the layer. To reinitialize the layer attributes to defaults settings, use the method <tt>reset()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['clearConsole']={syn:'Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.',lib:'displaylayer&rarr;clearConsole()',pro:'int clearConsole()',cmt:'<p>Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['consoleOut']={syn:'Outputs a message in the console area, and advances the console pointer accordingly.',lib:'displaylayer&rarr;consoleOut()',pro:'int consoleOut(string <span id=pn>text</span>)',cmt:'<p>Outputs a message in the console area, and advances the console pointer accordingly. The console pointer position is automatically moved to the beginning of the next line when a newline character is met, or when the right margin is hit. When the new text to display extends below the lower margin, the console area is automatically scrolled up.</p>',par:{text:'the message to display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBar']={syn:'Draws a filled rectangular bar at a specified position.',lib:'displaylayer&rarr;drawBar()',pro:'int drawBar(int <span id=pn>x1</span>, int <span id=pn>y1</span>, int <span id=pn>x2</span>, int <span id=pn>y2</span>)',cmt:'<p>Draws a filled rectangular bar at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBitmap']={syn:'Draws a bitmap at the specified position.',lib:'displaylayer&rarr;drawBitmap()',pro:'int drawBitmap(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>w</span>, string <span id=pn>bitmap</span>, int <span id=pn>bgcol</span>)',cmt:'<p>Draws a bitmap at the specified position. The bitmap is provided as a binary object, where each pixel maps to a bit, from left to right and from top to bottom. The most significant bit of each byte maps to the leftmost pixel, and the least significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the layer selected pen color. Bits set to 0 are drawn using the specified background gray level, unless -1 is specified, in which case they are not drawn at all (as if transparent).</p>',par:{x:'the distance from left of layer to the left of the bitmap, in pixels',y:'the distance from top of layer to the top of the bitmap, in pixels',w:'the width of the bitmap, in pixels',bitmap:'a binary object',bgcol:'the background gray level to use for zero bits (0 = black, 255 = white), or -1 to leave the pixels unchanged'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawCircle']={syn:'Draws an empty circle at a specified position.',lib:'displaylayer&rarr;drawCircle()',pro:'int drawCircle(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>r</span>)',cmt:'<p>Draws an empty circle at a specified position.</p>',par:{x:'the distance from left of layer to the center of the circle, in pixels',y:'the distance from top of layer to the center of the circle, in pixels',r:'the radius of the circle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawDisc']={syn:'Draws a filled disc at a given position.',lib:'displaylayer&rarr;drawDisc()',pro:'int drawDisc(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>r</span>)',cmt:'<p>Draws a filled disc at a given position.</p>',par:{x:'the distance from left of layer to the center of the disc, in pixels',y:'the distance from top of layer to the center of the disc, in pixels',r:'the radius of the disc, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawImage']={syn:'Draws a GIF image at the specified position.',lib:'displaylayer&rarr;drawImage()',pro:'int drawImage(int <span id=pn>x</span>, int <span id=pn>y</span>, string <span id=pn>imagename</span>)',cmt:'<p>Draws a GIF image at the specified position. The GIF image must have been previously uploaded to the device built-in memory. If you experience problems using an image file, check the device logs for any error message such as missing image file or bad image file format.</p>',par:{x:'the distance from left of layer to the left of the image, in pixels',y:'the distance from top of layer to the top of the image, in pixels',imagename:'the GIF file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawPixel']={syn:'Draws a single pixel at the specified position.',lib:'displaylayer&rarr;drawPixel()',pro:'int drawPixel(int <span id=pn>x</span>, int <span id=pn>y</span>)',cmt:'<p>Draws a single pixel at the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawRect']={syn:'Draws an empty rectangle at a specified position.',lib:'displaylayer&rarr;drawRect()',pro:'int drawRect(int <span id=pn>x1</span>, int <span id=pn>y1</span>, int <span id=pn>x2</span>, int <span id=pn>y2</span>)',cmt:'<p>Draws an empty rectangle at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawText']={syn:'Draws a text string at the specified position.',lib:'displaylayer&rarr;drawText()',pro:'int drawText(int <span id=pn>x</span>, int <span id=pn>y</span>, Y_ALIGN <span id=pn>anchor</span>, string <span id=pn>text</span>)',cmt:'<p>Draws a text string at the specified position. The point of the text that is aligned to the specified pixel position is called the anchor point, and can be chosen among several options. Text is rendered from left to right, without implicit wrapping.</p>',par:{x:'the distance from left of layer to the text ancor point, in pixels',y:'the distance from top of layer to the text ancor point, in pixels',anchor:'the text anchor point, chosen among the <tt>Y_ALIGN</tt> enumeration: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'the text string to draw'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['get_display']={syn:'Gets parent YDisplay.',lib:'displaylayer&rarr;get_display()',pro:'YDisplay* get_display()',cmt:'<p>Gets parent YDisplay. Returns the parent YDisplay object of the current YDisplayLayer.</p>',ret:'an <tt>YDisplay</tt> object'};
doc['DisplayLayer']['hide']={syn:'Hides the layer.',lib:'displaylayer&rarr;hide()',pro:'int hide()',cmt:'<p>Hides the layer. The state of the layer is perserved but the layer is not displayed on the screen until the next call to <tt>unhide()</tt>. Hiding the layer can positively affect the drawing speed, since it postpones the rendering until all operations are completed (double-buffering).</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['lineTo']={syn:'Draws a line from current drawing pointer position to the specified position.',lib:'displaylayer&rarr;lineTo()',pro:'int lineTo(int <span id=pn>x</span>, int <span id=pn>y</span>)',cmt:'<p>Draws a line from current drawing pointer position to the specified position. The specified destination pixel is included in the line. The pointer position is then moved to the end point of the line.</p>',par:{x:'the distance from left of layer to the end point of the line, in pixels',y:'the distance from top of layer to the end point of the line, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['moveTo']={syn:'Moves the drawing pointer of this layer to the specified position.',lib:'displaylayer&rarr;moveTo()',pro:'int moveTo(int <span id=pn>x</span>, int <span id=pn>y</span>)',cmt:'<p>Moves the drawing pointer of this layer to the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['reset']={syn:'Reverts the layer to its initial state (fully transparent, default settings).',lib:'displaylayer&rarr;reset()',pro:'int reset()',cmt:'<p>Reverts the layer to its initial state (fully transparent, default settings). Reinitializes the drawing pointer to the upper left position, and selects the most visible pen color. If you only want to erase the layer content, use the method <tt>clear()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectColorPen']={syn:'Selects the pen color for all subsequent drawing functions, including text drawing.',lib:'displaylayer&rarr;selectColorPen()',pro:'int selectColorPen(int <span id=pn>color</span>)',cmt:'<p>Selects the pen color for all subsequent drawing functions, including text drawing. The pen color is provided as an RGB value. For grayscale or monochrome displays, the value is automatically converted to the proper range.</p>',par:{color:'the desired pen color, as a 24-bit RGB value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectEraser']={syn:'Selects an eraser instead of a pen for all subsequent drawing functions, except for text drawing and bitmap copy functions.',lib:'displaylayer&rarr;selectEraser()',pro:'int selectEraser()',cmt:'<p>Selects an eraser instead of a pen for all subsequent drawing functions, except for text drawing and bitmap copy functions. Any point drawn using the eraser becomes transparent (as when the layer is empty), showing the other layers beneath it.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectFont']={syn:'Selects a font to use for the next text drawing functions, by providing the name of the font file.',lib:'displaylayer&rarr;selectFont()',pro:'int selectFont(string <span id=pn>fontname</span>)',cmt:'<p>Selects a font to use for the next text drawing functions, by providing the name of the font file. You can use a built-in font as well as a font file that you have previously uploaded to the device built-in memory. If you experience problems selecting a font file, check the device logs for any error message such as missing font file or bad font file format.</p>',par:{fontname:'the font file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectGrayPen']={syn:'Selects the pen gray level for all subsequent drawing functions, including text drawing.',lib:'displaylayer&rarr;selectGrayPen()',pro:'int selectGrayPen(int <span id=pn>graylevel</span>)',cmt:'<p>Selects the pen gray level for all subsequent drawing functions, including text drawing. The gray level is provided as a number between 0 (black) and 255 (white, or whichever the lighest color is). For monochrome displays (without gray levels), any value lower than 128 is rendered as black, and any value equal or above to 128 is non-black.</p>',par:{graylevel:'the desired gray level, from 0 to 255'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Enables or disables anti-aliasing for drawing oblique lines and circles.',lib:'displaylayer&rarr;setAntialiasingMode()',pro:'int setAntialiasingMode(bool <span id=pn>mode</span>)',cmt:'<p>Enables or disables anti-aliasing for drawing oblique lines and circles. Anti-aliasing provides a smoother aspect when looked from far enough, but it can add fuzzyness when the display is looked from very close. At the end of the day, it is your personal choice. Anti-aliasing is enabled by default on grayscale and color displays, but you can disable it if you prefer. This setting has no effect on monochrome displays.</p>',par:{mode:'<t>true</t> to enable antialiasing, <t>false</t> to disable it.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleBackground']={syn:'Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.',lib:'displaylayer&rarr;setConsoleBackground()',pro:'int setConsoleBackground(int <span id=pn>bgcol</span>)',cmt:'<p>Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.</p>',par:{bgcol:'the background gray level to use when scrolling (0 = black, 255 = white), or -1 for transparent'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleMargins']={syn:'Sets up display margins for the <tt>consoleOut</tt> function.',lib:'displaylayer&rarr;setConsoleMargins()',pro:'int setConsoleMargins(int <span id=pn>x1</span>, int <span id=pn>y1</span>, int <span id=pn>x2</span>, int <span id=pn>y2</span>)',cmt:'<p>Sets up display margins for the <tt>consoleOut</tt> function.</p>',par:{x1:'the distance from left of layer to the left margin, in pixels',y1:'the distance from top of layer to the top margin, in pixels',x2:'the distance from left of layer to the right margin, in pixels',y2:'the distance from top of layer to the bottom margin, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.',lib:'displaylayer&rarr;setConsoleWordWrap()',pro:'int setConsoleWordWrap(bool <span id=pn>wordwrap</span>)',cmt:'<p>Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.</p>',par:{wordwrap:'<tt>true</tt> to wrap only between words, <tt>false</tt> to wrap on the last column anyway.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setLayerPosition']={syn:'Sets the position of the layer relative to the display upper left corner.',lib:'displaylayer&rarr;setLayerPosition()',pro:'int setLayerPosition(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>scrollTime</span>)',cmt:'<p>Sets the position of the layer relative to the display upper left corner. When smooth scrolling is used, the display offset of the layer is automatically updated during the next milliseconds to animate the move of the layer.</p>',par:{x:'the distance from left of display to the upper left corner of the layer',y:'the distance from top of display to the upper left corner of the layer',scrollTime:'number of milliseconds to use for smooth scrolling, or 0 if the scrolling should be immediate.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['unhide']={syn:'Shows the layer.',lib:'displaylayer&rarr;unhide()',pro:'int unhide()',cmt:'<p>Shows the layer. Shows the layer again after a hide command.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DisplayLayer)
//--- (generated code: Files)
doc['Files']={'':{syn:'Files function interface',inc:'#include &quot;yocto_files.h&quot;',cmt:'<p>The filesystem interface makes it possible to store files on some devices, for instance to design a custom web UI (for networked devices) or to add fonts (on display devices).</p>'}};
doc['Files']['FindFiles']={syn:'Retrieves a filesystem for a given identifier.',lib:'YFiles::FindFiles()',pro:'YFiles* FindFiles(const string&amp; <span id=pn>func</span>)',cmt:'<p>Retrieves a filesystem for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the filesystem is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YFiles.isOnline()</tt> to test if the filesystem is indeed online at a given time. In case of ambiguity when looking for a filesystem by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the filesystem'},ret:'a <tt>YFiles</tt> object allowing you to drive the filesystem.'};
doc['Files']['FirstFiles']={syn:'Starts the enumeration of filesystems currently accessible.',lib:'YFiles::FirstFiles()',pro:'YFiles* FirstFiles()',cmt:'<p>Starts the enumeration of filesystems currently accessible. Use the method <tt>YFiles.nextFiles()</tt> to iterate on next filesystems.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to the first filesystem currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Files']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'files&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Files']['download']={syn:'Downloads the requested file and returns a binary buffer with its content.',lib:'files&rarr;download()',pro:'string download(string <span id=pn>pathname</span>)',cmt:'<p>Downloads the requested file and returns a binary buffer with its content.</p>',par:{pathname:'path and name of the new file to load'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns an empty content.'};
doc['Files']['format_fs']={syn:'Reinitializes the filesystem to its clean, unfragmented, empty state.',lib:'files&rarr;format_fs()',pro:'int format_fs()',cmt:'<p>Reinitializes the filesystem to its clean, unfragmented, empty state. All files previously uploaded are permanently lost.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['get_advertisedValue']={syn:'Returns the current value of the filesystem (no more than 6 characters).',lib:'files&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the filesystem (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the filesystem (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Files']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'files&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Files']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'files&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Files']['get_filesCount']={syn:'Returns the number of files currently loaded in the filesystem.',lib:'files&rarr;get_filesCount()',pro:'unsigned get_filesCount()',cmt:'<p>Returns the number of files currently loaded in the filesystem.</p>',ret:'an integer corresponding to the number of files currently loaded in the filesystem',ext:'On failure, throws an exception or returns <tt>Y_FILESCOUNT_INVALID</tt>.'};
doc['Files']['get_freeSpace']={syn:'Returns the free space for uploading new files to the filesystem, in bytes.',lib:'files&rarr;get_freeSpace()',pro:'unsigned get_freeSpace()',cmt:'<p>Returns the free space for uploading new files to the filesystem, in bytes.</p>',ret:'an integer corresponding to the free space for uploading new files to the filesystem, in bytes',ext:'On failure, throws an exception or returns <tt>Y_FREESPACE_INVALID</tt>.'};
doc['Files']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'files&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Files']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'files&rarr;get_filesDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Files']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'files&rarr;get_filesId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Files']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'files&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL&#46;FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Files']['get_logicalName']={syn:'Returns the logical name of the filesystem.',lib:'files&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the filesystem.</p>',ret:'a string corresponding to the logical name of the filesystem',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Files']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'files&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Files']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'files&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Files']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'files&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Files']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'files&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Files']['nextFiles']={syn:'Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.',lib:'files&rarr;nextFiles()',pro:'YFiles * nextFiles()',cmt:'<p>Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to a filesystem currently online, or a <tt>null</tt> pointer if there are no more filesystems to enumerate.'};
doc['Files']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'files&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Files']['remove']={syn:'Deletes a file, given by its full path name, from the filesystem.',lib:'files&rarr;remove()',pro:'int remove(string <span id=pn>pathname</span>)',cmt:'<p>Deletes a file, given by its full path name, from the filesystem. Because of filesystem fragmentation, deleting a file may not always free up the whole space used by the file. However, rewriting a file with the same path name will always reuse any space not freed previously. If you need to ensure that no space is taken by previously deleted files, you can use <tt>format_fs</tt> to fully reinitialize the filesystem.</p>',par:{pathname:'path and name of the file to remove.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_logicalName']={syn:'Changes the logical name of the filesystem.',lib:'files&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the filesystem. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the filesystem'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'files&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Files']['upload']={syn:'Uploads a file to the filesystem, to the specified full path name.',lib:'files&rarr;upload()',pro:'int upload(string <span id=pn>pathname</span>, string <span id=pn>content</span>)',cmt:'<p>Uploads a file to the filesystem, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Files)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 } 	 

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);  
 }	  
 
function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);  
 }	  

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 } 
 
function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }
 
function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist." 
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 } 
 
function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."  
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }
 
function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."  
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."  
    it.style.top  = parseInt(t) + "px";
 } 

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."  
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }
 
function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }
 
function computeWinWH()
 { WinW             = GetWindowWidth() ;  
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight(); 
   if (WinH<400) WinH=400;
} 

 
 function getInnerHeight()   
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );  
 }		
 
 function getInnerWidth()   
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct) 
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct; 
  }
  
function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++) 
      resizeCallBacks[i]();
  }  

function jsQuote(str_in) 
{ str_in = str_in+'';
  var str_out   = ''; 
  for (i=0;i<str_in.length;i++) 
   { 
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else 
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex; 
      }  
   } 
   return str_out; 
  }  
 

function resizeMargin()
 { 
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 } 
 
function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110); 
 }
 
function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 } 
 
function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches) 
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }  
  return new positionObject(x,y);
 } 
 
  
function EnableDrag(var_element,onDragMove,onDragEnd)
  {  
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y   
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }  
   else 
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);
       
   if (onDragMove)  var_element.onDragMove = onDragMove;    
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;    
  }
  
 var LastDraggedObject = null;  
  
 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos) 
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;    
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;
   
   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }
   
   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }
      
   if (event.preventDefault)   event.preventDefault();  
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source, 
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else  
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    } 
   document.onmouseup   =   Drag_stopMouseCapture;
 } 
 
 
function Drag_mouseCapture(event)
 { 
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault(); 

 
   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y); 
   
   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;
   
   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;
   
   var p = {x:x,y:y};
  
   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);
    
   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;
    
   lastDraggedObject.element.style.left = p.x+"px";  
   lastDraggedObject.element.style.top  = p.y+"px";  
 }

function Drag_stopMouseCapture()
 { 
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent) 
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }
 
  if (lastDraggedObject) 
    { lastDraggedObject.element.style.cursor='col-resize';   
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }  
 
 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin() 
  }
  
 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  { 
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }
  
    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex; 
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par) 
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'   
          }      

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }              
        
         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }      
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml; 
  } 
  
  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else  
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }    
  } 
  
 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname) 
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'>&nbsp;<img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";
        
       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }  
       }
       marginhtml = marginhtml+'</div>'  
    }
  
    document.getElementById("MarginLayer").innerHTML = marginhtml; 
  }
  
 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()
    
    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }
    
    for (var i=0;i<tosearch.length;i++) 
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }            
          
          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }              
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;    
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;
          
          if (!found) return false;
       }       
    
  
    return true;

  }
 
 var searchTimer = null; 
 
 function doSearch()
  { searchTimer = null; 
    var value= document.forms['yoctoForm'].elements['search'].value;
    
    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           } 
          container["originalDisplay"]=null;           
        }
        Show(lastindex_shown,lastname_shown);
       return;        
      }   
      
    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');  
       for (var method in doc[classname])
       
         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}        
                 } 
              else 
                 { if (it) it.style.display="none";
                 } 
         } 
        
      if  (matchfound) 
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }
   
    Show(firstindex,firstname); 
        
    
  }
  
 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }  
  
 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown); 
    Show(lastindex_shown,lastname_shown); 

  }
  

 
 
 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form> 
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" language="javascript1.5"> 
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);  
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" checked onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;
   
 
 }
doc = sortObject(doc);
ShowFunctions(); 
Show(doc["YAPI"]?"YAPI":"Module",""); 


window.onresize = windowResized;  
-->  
</script>

</BODY>


</HEAD>

